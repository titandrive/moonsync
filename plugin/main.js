/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MoonSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  dropboxPath: "",
  outputFolder: "Books",
  syncOnStartup: true,
  showRibbonIcon: true,
  showDescription: true,
  showReadingProgress: true,
  showHighlightColors: true,
  showCovers: true,
  showIndex: true,
  indexNoteTitle: "1. Library Index",
  generateBaseFile: true,
  baseFileName: "2. Books Database",
  showCoverCollage: true,
  coverCollageLimit: 0,
  // 0 = show all
  coverCollageSort: "alpha",
  trackBooksWithoutHighlights: false
};
function getCalloutType(colorInt) {
  const r = colorInt >> 16 & 255;
  const g = colorInt >> 8 & 255;
  const b = colorInt & 255;
  if (r > 200 && g > 200 && b < 100) {
    return "quote";
  }
  if (b > r && b > g && b > 150) {
    return "info";
  }
  if (g > r && g > b && g > 150) {
    return "tip";
  }
  if (r > g && r > b && r > 150) {
    return "warning";
  }
  if (r > 200 && g > 100 && g < 200 && b < 100) {
    return "warning";
  }
  return "quote";
}
function formatDuration(ms) {
  const totalMinutes = Math.floor(ms / 6e4);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
}
function formatDate(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric"
  });
}

// src/settings.ts
var import_obsidian = require("obsidian");
var MoonSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.activeTab = "configuration";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "MoonSync Settings" });
    const tabNav = containerEl.createDiv({ cls: "moonsync-tab-nav" });
    const tabs = [
      { id: "configuration", name: "Configuration" },
      { id: "content", name: "Content" },
      { id: "index-base", name: "Index & Base" },
      { id: "about", name: "About" }
    ];
    tabs.forEach((tab) => {
      const tabButton = tabNav.createEl("button", {
        text: tab.name,
        cls: this.activeTab === tab.id ? "moonsync-tab-button moonsync-tab-active" : "moonsync-tab-button"
      });
      tabButton.addEventListener("click", () => {
        this.activeTab = tab.id;
        this.display();
      });
    });
    const configTab = containerEl.createDiv({ cls: this.activeTab === "configuration" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    const contentTab = containerEl.createDiv({ cls: this.activeTab === "content" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    const indexBaseTab = containerEl.createDiv({ cls: this.activeTab === "index-base" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    const aboutTab = containerEl.createDiv({ cls: this.activeTab === "about" ? "moonsync-tab-content moonsync-tab-visible" : "moonsync-tab-content moonsync-tab-hidden" });
    this.displayConfigurationTab(configTab);
    this.displayContentTab(contentTab);
    this.displayIndexBaseTab(indexBaseTab);
    this.displayAboutTab(aboutTab);
  }
  displayConfigurationTab(container) {
    container.createEl("h3", { text: "Configuration" });
    container.createEl("p", { text: "Set up your Moon Reader backup location and note output folder.", cls: "moonsync-section-desc" });
    let textComponent;
    let validationEl;
    const pathSetting = new import_obsidian.Setting(container).setName("Moon Reader Dropbox Path").setDesc(
      "Path to your Books folder in Dropbox (usually Dropbox/Apps/Books). The plugin will find the hidden .Moon+ folder automatically."
    ).addText((text) => {
      textComponent = text;
      text.setPlaceholder("/Users/you/Dropbox/Apps/Books").setValue(this.plugin.settings.dropboxPath).onChange(async (value) => {
        this.plugin.settings.dropboxPath = value;
        await this.plugin.saveSettings();
        await this.validateDropboxPath(value, validationEl);
      });
    }).addButton(
      (button) => button.setButtonText("Browse").onClick(async () => {
        const folder = await this.openFolderPicker();
        if (folder) {
          this.plugin.settings.dropboxPath = folder;
          textComponent.setValue(folder);
          await this.plugin.saveSettings();
          await this.validateDropboxPath(folder, validationEl);
        }
      })
    );
    validationEl = pathSetting.descEl.createDiv({ cls: "moonsync-path-validation" });
    if (this.plugin.settings.dropboxPath) {
      this.validateDropboxPath(this.plugin.settings.dropboxPath, validationEl);
    }
    new import_obsidian.Setting(container).setName("Output Folder").setDesc("Folder in your vault where book notes will be created").addText(
      (text) => text.setPlaceholder("Books").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
        this.plugin.settings.outputFolder = value || "Books";
        await this.plugin.saveSettings();
      })
    );
    container.createEl("h3", { text: "Sync", attr: { style: "margin-top: 2em;" } });
    container.createEl("p", { text: "Control when and how MoonSync syncs your highlights.", cls: "moonsync-section-desc" });
    new import_obsidian.Setting(container).setName("Sync Now").setDesc("Manually trigger a sync from Moon Reader").addButton(
      (button) => button.setButtonText("Sync").onClick(async () => {
        await this.plugin.runSync();
      })
    );
    new import_obsidian.Setting(container).setName("Sync on Startup").setDesc("Automatically sync when Obsidian starts").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.syncOnStartup).onChange(async (value) => {
        this.plugin.settings.syncOnStartup = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(container).setName("Show Ribbon Icon").setDesc("Show sync button in ribbon menu").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showRibbonIcon).onChange(async (value) => {
        this.plugin.settings.showRibbonIcon = value;
        await this.plugin.saveSettings();
        this.plugin.updateRibbonIcon();
      })
    );
    new import_obsidian.Setting(container).setName("Track Books Without Highlights").setDesc("Track books you have started reading but have no existing highlights or notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.trackBooksWithoutHighlights).onChange(async (value) => {
        this.plugin.settings.trackBooksWithoutHighlights = value;
        await this.plugin.saveSettings();
      })
    );
  }
  displayContentTab(container) {
    container.createEl("h3", { text: "Note Content" });
    container.createEl("p", { text: "Control what data is included in your book notes.", cls: "moonsync-section-desc" });
    new import_obsidian.Setting(container).setName("Show Description").setDesc("Include book description in generated notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showDescription).onChange(async (value) => {
        this.plugin.settings.showDescription = value;
        await this.plugin.saveSettings();
        this.plugin.updateContentVisibility();
      })
    );
    new import_obsidian.Setting(container).setName("Show Reading Progress").setDesc("Include reading progress section. Note: Progress data may not always be accurate depending on Moon Reader sync.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showReadingProgress).onChange(async (value) => {
        this.plugin.settings.showReadingProgress = value;
        await this.plugin.saveSettings();
        this.plugin.updateContentVisibility();
      })
    );
    new import_obsidian.Setting(container).setName("Show Highlight Colors").setDesc("Use different callout styles based on highlight color. When off, all highlights appear as quotes.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showHighlightColors).onChange(async (value) => {
        this.plugin.settings.showHighlightColors = value;
        await this.plugin.saveSettings();
        this.plugin.updateContentVisibility();
      })
    );
    new import_obsidian.Setting(container).setName("Show Book Covers").setDesc("Display book covers in notes. Covers are always downloaded to the 'covers' subfolder.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showCovers).onChange(async (value) => {
        this.plugin.settings.showCovers = value;
        await this.plugin.saveSettings();
        this.plugin.updateContentVisibility();
      })
    );
  }
  displayIndexBaseTab(container) {
    container.createEl("h3", { text: "Library Index" });
    container.createEl("p", { text: "Configure the automatically generated index of all your books.", cls: "moonsync-section-desc" });
    new import_obsidian.Setting(container).setName("Generate Library Index").setDesc("Create an index note with summary stats and links to all books. Turning this off will delete the existing index note.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showIndex).onChange(async (value) => {
        this.plugin.settings.showIndex = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.refreshIndex();
        } else {
          await this.plugin.deleteIndex();
        }
      })
    );
    new import_obsidian.Setting(container).setName("Index Note Title").setDesc("Name of the library index note. Changing this will rename the existing file.").addText(
      (text) => text.setPlaceholder("1. Library Index").setValue(this.plugin.settings.indexNoteTitle).onChange(async (value) => {
        const oldName = this.plugin.settings.indexNoteTitle;
        const newName = value || "1. Library Index";
        if (oldName !== newName) {
          if (this.plugin.settings.showIndex) {
            await this.plugin.renameIndex(oldName, newName);
          }
          this.plugin.settings.indexNoteTitle = newName;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(container).setName("Show Cover Collage").setDesc("Display book covers at the top of the library index").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showCoverCollage).onChange(async (value) => {
        this.plugin.settings.showCoverCollage = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    new import_obsidian.Setting(container).setName("Cover Collage Limit").setDesc("Maximum number of covers to show (0 = show all)").addText(
      (text) => text.setPlaceholder("0").setValue(String(this.plugin.settings.coverCollageLimit)).onChange(async (value) => {
        const num = parseInt(value) || 0;
        this.plugin.settings.coverCollageLimit = Math.max(0, num);
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    new import_obsidian.Setting(container).setName("Cover Collage Sort").setDesc("How to sort covers in the collage").addDropdown(
      (dropdown) => dropdown.addOption("alpha", "Alphabetical").addOption("recent", "Most Recent").setValue(this.plugin.settings.coverCollageSort).onChange(async (value) => {
        this.plugin.settings.coverCollageSort = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    container.createEl("h3", { text: "Obsidian Bases", attr: { style: "margin-top: 2em;" } });
    container.createEl("p", { text: "Automatically generate a database configuration file for the Obsidian Bases plugin.", cls: "moonsync-section-desc" });
    new import_obsidian.Setting(container).setName("Generate Base File").setDesc("Automatically create and update the .base file for the Obsidian Bases plugin. Turning this off will delete the existing base file.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.generateBaseFile).onChange(async (value) => {
        this.plugin.settings.generateBaseFile = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.refreshBase();
        } else {
          await this.plugin.deleteBase();
        }
      })
    );
    new import_obsidian.Setting(container).setName("Base File Name").setDesc("Name of the .base file (without extension). Changing this will rename the existing file.").addText(
      (text) => text.setPlaceholder("2. Books Database").setValue(this.plugin.settings.baseFileName).onChange(async (value) => {
        const oldName = this.plugin.settings.baseFileName;
        const newName = value || "2. Books Database";
        if (oldName !== newName) {
          if (this.plugin.settings.generateBaseFile) {
            await this.plugin.renameBase(oldName, newName);
          }
          this.plugin.settings.baseFileName = newName;
          await this.plugin.saveSettings();
        }
      })
    );
  }
  displayAboutTab(container) {
    container.createEl("h3", { text: "About MoonSync" });
    new import_obsidian.Setting(container).setName("Sync your Moon Reader highlights to Obsidian").setDesc("Book covers, descriptions, and metadata from Google Books/Open Library").addButton(
      (button) => button.setButtonText("GitHub").onClick(() => {
        window.open("https://github.com/titandrive/moonsync");
      })
    );
    container.createEl("h3", { text: "Support", attr: { style: "margin-top: 2em;" } });
    new import_obsidian.Setting(container).setName("Buy me a coffee").setDesc("If you find this plugin useful, consider supporting its development!").addButton(
      (button) => button.setButtonText("Ko-fi").onClick(() => {
        window.open("https://ko-fi.com/titandrive");
      })
    );
  }
  async validateDropboxPath(path, validationEl) {
    validationEl.empty();
    if (!path) {
      return;
    }
    const { existsSync } = require("fs");
    const { join: join3 } = require("path");
    const cachePath = join3(path, ".Moon+", "Cache");
    if (existsSync(cachePath)) {
      validationEl.createSpan({
        text: "\u2713 Moon Reader cache folder found",
        attr: { style: "color: var(--text-success); font-size: 0.85em; margin-top: 0.5em; display: block;" }
      });
    } else {
      validationEl.createSpan({
        text: "\u26A0 .Moon+/Cache folder not found at this path",
        attr: { style: "color: var(--text-warning); font-size: 0.85em; margin-top: 0.5em; display: block;" }
      });
    }
  }
  async openFolderPicker() {
    const { exec } = require("child_process");
    const { platform } = require("os");
    return new Promise((resolve) => {
      if (platform() === "darwin") {
        const script = `osascript -e 'POSIX path of (choose folder with prompt "Select Moon Reader Dropbox folder")'`;
        exec(script, (error, stdout) => {
          if (error) {
            resolve(null);
          } else {
            resolve(stdout.trim());
          }
        });
      } else if (platform() === "win32") {
        const script = `powershell -command "Add-Type -AssemblyName System.Windows.Forms; $f = New-Object System.Windows.Forms.FolderBrowserDialog; $f.ShowDialog() | Out-Null; $f.SelectedPath"`;
        exec(script, (error, stdout) => {
          if (error) {
            resolve(null);
          } else {
            resolve(stdout.trim());
          }
        });
      } else {
        exec(
          'zenity --file-selection --directory --title="Select Moon Reader folder"',
          (error, stdout) => {
            if (error) {
              resolve(null);
            } else {
              resolve(stdout.trim());
            }
          }
        );
      }
    });
  }
};

// src/sync.ts
var import_obsidian6 = require("obsidian");

// src/modal.ts
var import_obsidian3 = require("obsidian");

// src/covers.ts
var import_obsidian2 = require("obsidian");
async function fetchBookInfo(title, author) {
  const [openLibraryResult, googleBooksResult] = await Promise.all([
    fetchFromOpenLibrary(title, author),
    fetchFromGoogleBooks(title, author)
  ]);
  const coverUrl = openLibraryResult.coverUrl || googleBooksResult.coverUrl;
  const description = googleBooksResult.description || openLibraryResult.description;
  const fetchedTitle = googleBooksResult.title || openLibraryResult.title;
  const fetchedAuthor = googleBooksResult.author || openLibraryResult.author;
  const publishedDate = googleBooksResult.publishedDate || openLibraryResult.publishedDate;
  const publisher = googleBooksResult.publisher || openLibraryResult.publisher;
  const pageCount = googleBooksResult.pageCount || openLibraryResult.pageCount;
  const language = googleBooksResult.language || openLibraryResult.language;
  const genres = [];
  if (googleBooksResult.genres) {
    genres.push(...googleBooksResult.genres);
  }
  if (openLibraryResult.genres) {
    for (const genre of openLibraryResult.genres) {
      if (!genres.some((g) => g.toLowerCase() === genre.toLowerCase())) {
        genres.push(genre);
      }
    }
  }
  const series = openLibraryResult.series;
  let source = null;
  if (coverUrl || description) {
    source = googleBooksResult.description ? "googlebooks" : "openlibrary";
  }
  return {
    title: fetchedTitle,
    coverUrl,
    description,
    author: fetchedAuthor,
    source,
    publishedDate,
    publisher,
    pageCount,
    genres: genres.length > 0 ? genres : null,
    series,
    language
  };
}
async function batchFetchBookInfo(books, concurrency = 5) {
  const results = /* @__PURE__ */ new Map();
  for (let i = 0; i < books.length; i += concurrency) {
    const chunk = books.slice(i, i + concurrency);
    const chunkResults = await Promise.all(
      chunk.map(async (book) => {
        const key = `${book.title}|${book.author}`;
        try {
          const info = await fetchBookInfo(book.title, book.author);
          return { key, info };
        } catch (error) {
          console.log(`MoonSync: Failed to fetch info for "${book.title}"`, error);
          return { key, info: null };
        }
      })
    );
    for (const { key, info } of chunkResults) {
      if (info) {
        results.set(key, info);
      }
    }
  }
  return results;
}
async function fetchFromOpenLibrary(title, author) {
  const result = {
    title: null,
    coverUrl: null,
    description: null,
    author: null,
    publishedDate: null,
    publisher: null,
    pageCount: null,
    genres: null,
    series: null,
    language: null
  };
  try {
    const query = encodeURIComponent(`${title} ${author}`);
    const searchUrl = `https://openlibrary.org/search.json?q=${query}&limit=1`;
    const response = await (0, import_obsidian2.requestUrl)({ url: searchUrl });
    const data = response.json;
    if (data.docs && data.docs.length > 0) {
      const book = data.docs[0];
      if (book.title) {
        result.title = book.title;
      }
      if (book.cover_i) {
        result.coverUrl = `https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg`;
      } else if (book.isbn && book.isbn.length > 0) {
        result.coverUrl = `https://covers.openlibrary.org/b/isbn/${book.isbn[0]}-L.jpg`;
      }
      if (book.author_name && book.author_name.length > 0) {
        result.author = book.author_name[0];
      }
      if (book.first_publish_year) {
        result.publishedDate = book.first_publish_year.toString();
      }
      if (book.publisher && book.publisher.length > 0) {
        result.publisher = book.publisher[0];
      }
      if (book.number_of_pages_median) {
        result.pageCount = book.number_of_pages_median;
      }
      if (book.subject && book.subject.length > 0) {
        result.genres = book.subject.slice(0, 5);
      }
      if (book.language && book.language.length > 0) {
        result.language = book.language[0];
      }
      if (book.key) {
        try {
          const workUrl = `https://openlibrary.org${book.key}.json`;
          const workResponse = await (0, import_obsidian2.requestUrl)({ url: workUrl });
          const workData = workResponse.json;
          if (workData.description) {
            result.description = typeof workData.description === "string" ? workData.description : workData.description.value || null;
          }
          if (workData.series && workData.series.length > 0) {
            result.series = workData.series[0];
          }
        } catch (e) {
        }
      }
    }
  } catch (error) {
    console.log("MoonSync: Open Library search failed", error);
  }
  return result;
}
async function fetchFromGoogleBooks(title, author) {
  var _a;
  const result = {
    title: null,
    coverUrl: null,
    description: null,
    author: null,
    publishedDate: null,
    publisher: null,
    pageCount: null,
    genres: null,
    language: null
  };
  try {
    const query = author ? `${title} ${author}` : title;
    const searchUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=1`;
    const response = await (0, import_obsidian2.requestUrl)({ url: searchUrl });
    const data = response.json;
    if (data.items && data.items.length > 0) {
      const book = data.items[0];
      const volumeInfo = book.volumeInfo;
      if (volumeInfo == null ? void 0 : volumeInfo.title) {
        result.title = volumeInfo.title;
      }
      const imageLinks = volumeInfo == null ? void 0 : volumeInfo.imageLinks;
      if (imageLinks) {
        result.coverUrl = (_a = imageLinks.large || imageLinks.medium || imageLinks.thumbnail || imageLinks.smallThumbnail) == null ? void 0 : _a.replace("http://", "https://");
      }
      if (volumeInfo == null ? void 0 : volumeInfo.description) {
        result.description = volumeInfo.description;
      }
      if ((volumeInfo == null ? void 0 : volumeInfo.authors) && volumeInfo.authors.length > 0) {
        result.author = volumeInfo.authors[0];
      }
      if (volumeInfo == null ? void 0 : volumeInfo.publishedDate) {
        result.publishedDate = volumeInfo.publishedDate;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.publisher) {
        result.publisher = volumeInfo.publisher;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.pageCount) {
        result.pageCount = volumeInfo.pageCount;
      }
      if ((volumeInfo == null ? void 0 : volumeInfo.categories) && volumeInfo.categories.length > 0) {
        result.genres = volumeInfo.categories;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.language) {
        result.language = volumeInfo.language;
      }
    }
  } catch (error) {
    console.log("MoonSync: Google Books search failed", error);
  }
  return result;
}
async function fetchMultipleBookCovers(title, author, maxResults = 10) {
  var _a, _b, _c, _d, _e, _f, _g;
  const results = [];
  try {
    const googleQuery = author ? `${title} ${author}` : title;
    const googleUrl = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(googleQuery)}&maxResults=${maxResults}`;
    const googleResponse = await (0, import_obsidian2.requestUrl)({ url: googleUrl });
    const googleData = googleResponse.json;
    if (googleData.items && googleData.items.length > 0) {
      for (const book of googleData.items) {
        const volumeInfo = book.volumeInfo;
        const imageLinks = volumeInfo == null ? void 0 : volumeInfo.imageLinks;
        if (imageLinks) {
          const coverUrl = (_a = imageLinks.large || imageLinks.medium || imageLinks.thumbnail || imageLinks.smallThumbnail) == null ? void 0 : _a.replace("http://", "https://");
          if (coverUrl) {
            results.push({
              title: (volumeInfo == null ? void 0 : volumeInfo.title) || null,
              author: ((_b = volumeInfo == null ? void 0 : volumeInfo.authors) == null ? void 0 : _b[0]) || null,
              coverUrl,
              description: (volumeInfo == null ? void 0 : volumeInfo.description) || null,
              source: "googlebooks",
              publishedDate: (volumeInfo == null ? void 0 : volumeInfo.publishedDate) || null,
              publisher: (volumeInfo == null ? void 0 : volumeInfo.publisher) || null,
              pageCount: (volumeInfo == null ? void 0 : volumeInfo.pageCount) || null,
              genres: (volumeInfo == null ? void 0 : volumeInfo.categories) || null,
              series: null,
              language: (volumeInfo == null ? void 0 : volumeInfo.language) || null
            });
          }
        }
      }
    }
  } catch (error) {
    console.log("MoonSync: Google Books search failed", error);
  }
  try {
    const olQuery = encodeURIComponent(`${title} ${author}`);
    const olUrl = `https://openlibrary.org/search.json?q=${olQuery}&limit=${maxResults}`;
    const olResponse = await (0, import_obsidian2.requestUrl)({ url: olUrl });
    const olData = olResponse.json;
    if (olData.docs && olData.docs.length > 0) {
      for (const book of olData.docs) {
        let coverUrl = null;
        if (book.cover_i) {
          coverUrl = `https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg`;
        } else if (book.isbn && book.isbn.length > 0) {
          coverUrl = `https://covers.openlibrary.org/b/isbn/${book.isbn[0]}-L.jpg`;
        }
        if (coverUrl) {
          results.push({
            title: book.title || null,
            author: ((_c = book.author_name) == null ? void 0 : _c[0]) || null,
            coverUrl,
            description: null,
            // Would need extra API call per book
            source: "openlibrary",
            publishedDate: ((_d = book.first_publish_year) == null ? void 0 : _d.toString()) || null,
            publisher: ((_e = book.publisher) == null ? void 0 : _e[0]) || null,
            pageCount: book.number_of_pages_median || null,
            genres: ((_f = book.subject) == null ? void 0 : _f.slice(0, 5)) || null,
            series: null,
            language: ((_g = book.language) == null ? void 0 : _g[0]) || null
          });
        }
      }
    }
  } catch (error) {
    console.log("MoonSync: Open Library search failed", error);
  }
  const uniqueResults = results.filter(
    (result, index, self) => index === self.findIndex((r) => r.coverUrl === result.coverUrl)
  );
  return uniqueResults;
}
async function downloadCover(url) {
  try {
    const response = await (0, import_obsidian2.requestUrl)({ url });
    return response.arrayBuffer;
  } catch (error) {
    console.log("MoonSync: Failed to download cover", error);
    return null;
  }
}
async function downloadAndResizeCover(url, maxWidth = 400, maxHeight = 600) {
  try {
    const response = await (0, import_obsidian2.requestUrl)({ url });
    const arrayBuffer = response.arrayBuffer;
    const blob = new Blob([arrayBuffer]);
    const imageBitmap = await createImageBitmap(blob);
    let width = imageBitmap.width;
    let height = imageBitmap.height;
    if (width > maxWidth) {
      height = height * maxWidth / width;
      width = maxWidth;
    }
    if (height > maxHeight) {
      width = width * maxHeight / height;
      height = maxHeight;
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      console.log("MoonSync: Failed to get canvas context");
      return arrayBuffer;
    }
    ctx.drawImage(imageBitmap, 0, 0, width, height);
    const resizedBlob = await new Promise((resolve) => {
      canvas.toBlob((blob2) => resolve(blob2), "image/jpeg", 0.85);
    });
    if (!resizedBlob) {
      return arrayBuffer;
    }
    return await resizedBlob.arrayBuffer();
  } catch (error) {
    console.log("MoonSync: Failed to download/resize cover", error);
    return null;
  }
}

// src/modal.ts
var SyncSummaryModal = class extends import_obsidian3.Modal {
  constructor(app, result, settings) {
    super(app);
    this.result = result;
    this.settings = settings;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-summary-modal");
    const hasFailures = this.result.failedBooks && this.result.failedBooks.length > 0;
    const title = hasFailures ? "MoonSync Import Complete (with errors)" : "MoonSync Import Complete";
    contentEl.createEl("h2", { text: title });
    const statsContainer = contentEl.createDiv({ cls: "moonsync-stats" });
    this.createStatItem(statsContainer, this.result.booksCreated.toString(), "Books Imported");
    this.createStatItem(statsContainer, this.result.booksCreated.toString(), "Notes Created");
    this.createStatItem(statsContainer, this.result.totalHighlights.toString(), "Highlights");
    this.createStatItem(statsContainer, this.result.totalNotes.toString(), "Notes");
    if (hasFailures) {
      const failedSection = contentEl.createDiv({ cls: "moonsync-failed-section" });
      failedSection.createEl("h3", { text: `Failed (${this.result.failedBooks.length})` });
      const failedList = failedSection.createEl("ul", { cls: "moonsync-failed-list" });
      for (const failed of this.result.failedBooks) {
        const item = failedList.createEl("li");
        item.createSpan({ text: failed.title, cls: "moonsync-failed-title" });
        item.createSpan({ text: ` - ${failed.error}`, cls: "moonsync-failed-error" });
      }
    }
    const settingsLink = contentEl.createDiv({ cls: "moonsync-settings-link" });
    const link = settingsLink.createEl("a", { text: "Open MoonSync Settings" });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.close();
      this.app.setting.open();
      this.app.setting.openTabById("moonsync");
    });
    const buttonContainer = contentEl.createDiv({ cls: "moonsync-button-container" });
    const openIndexButton = buttonContainer.createEl("button", { text: "Open Library" });
    openIndexButton.addEventListener("click", async () => {
      this.close();
      const indexPath = (0, import_obsidian3.normalizePath)(`${this.settings.outputFolder}/${this.settings.indexNoteTitle}.md`);
      const file = this.app.vault.getAbstractFileByPath(indexPath);
      if (file) {
        await this.app.workspace.openLinkText(indexPath, "", false);
      }
    });
    const closeButton = buttonContainer.createEl("button", { text: "Done" });
    closeButton.addEventListener("click", () => this.close());
  }
  createStatItem(container, value, label) {
    const item = container.createDiv({ cls: "moonsync-stat-item" });
    item.createDiv({ cls: "moonsync-stat-value", text: value });
    item.createDiv({ cls: "moonsync-stat-label", text: label });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SelectCoverModal = class extends import_obsidian3.Modal {
  constructor(app, title, author, onSelect) {
    super(app);
    this.customUrl = "";
    this.resultsContainer = null;
    this.title = title;
    this.author = author;
    this.onSelect = onSelect;
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-select-cover-modal");
    modalEl.addClass("mod-moonsync-cover");
    contentEl.createEl("h2", { text: "Fetch Book Cover" });
    const tabNav = contentEl.createDiv({ cls: "moonsync-tab-nav" });
    const searchTab = tabNav.createEl("button", { text: "Search", cls: "moonsync-tab active" });
    const urlTab = tabNav.createEl("button", { text: "Import", cls: "moonsync-tab" });
    const searchContent = contentEl.createDiv({ cls: "moonsync-tab-content active" });
    const urlContent = contentEl.createDiv({ cls: "moonsync-tab-content" });
    searchTab.addEventListener("click", () => {
      searchTab.addClass("active");
      urlTab.removeClass("active");
      searchContent.addClass("active");
      urlContent.removeClass("active");
    });
    urlTab.addEventListener("click", () => {
      urlTab.addClass("active");
      searchTab.removeClass("active");
      urlContent.addClass("active");
      searchContent.removeClass("active");
    });
    const titleSetting = new import_obsidian3.Setting(searchContent).setName("Title").addText((text) => {
      text.setPlaceholder("Enter book title").setValue(this.title).onChange((value) => {
        this.title = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          this.performSearch();
        }
      });
    });
    titleSetting.settingEl.addClass("moonsync-labeled-field");
    const authorSetting = new import_obsidian3.Setting(searchContent).setName("Author").addText((text) => {
      text.setPlaceholder("Enter author name").setValue(this.author).onChange((value) => {
        this.author = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          this.performSearch();
        }
      });
    });
    authorSetting.settingEl.addClass("moonsync-labeled-field");
    new import_obsidian3.Setting(searchContent).addButton((button) => {
      button.setButtonText("Search").setCta().onClick(() => this.performSearch());
    });
    this.resultsContainer = searchContent.createDiv({ cls: "moonsync-cover-results" });
    urlContent.createEl("p", {
      text: "If search can't find the cover, or you have one you prefer, you can import it here.",
      cls: "moonsync-url-description"
    });
    const urlSetting = new import_obsidian3.Setting(urlContent).setName("URL").addText((text) => {
      text.setPlaceholder("https://example.com/cover.jpg").onChange((value) => {
        this.customUrl = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          if (this.customUrl.trim()) {
            this.onSelect(this.customUrl.trim());
            this.close();
          }
        }
      });
    });
    urlSetting.settingEl.addClass("moonsync-labeled-field");
    new import_obsidian3.Setting(urlContent).addButton((button) => {
      button.setButtonText("Import").setCta().onClick(() => {
        if (this.customUrl.trim()) {
          this.onSelect(this.customUrl.trim());
          this.close();
        }
      });
    });
    setTimeout(() => this.performSearch(), 150);
  }
  async performSearch() {
    if (!this.resultsContainer)
      return;
    this.resultsContainer.empty();
    if (!this.title.trim()) {
      this.resultsContainer.createEl("p", {
        text: "Please enter a book title.",
        cls: "setting-item-description"
      });
      return;
    }
    const loadingEl = this.resultsContainer.createDiv({ cls: "moonsync-loading" });
    loadingEl.setText("Searching for covers...");
    const covers = await fetchMultipleBookCovers(this.title, this.author, 10);
    loadingEl.remove();
    if (covers.length === 0) {
      this.resultsContainer.createEl("p", {
        text: "No covers found. Try a different search query.",
        cls: "setting-item-description"
      });
      return;
    }
    this.resultsContainer.createEl("p", {
      text: `Found ${covers.length} result${covers.length === 1 ? "" : "s"} for "${this.title}"${this.author ? ` by ${this.author}` : ""}`,
      cls: "moonsync-search-info"
    });
    const gridContainer = this.resultsContainer.createDiv({ cls: "moonsync-cover-grid" });
    for (const cover of covers) {
      const coverItem = gridContainer.createDiv({ cls: "moonsync-cover-item" });
      const img = coverItem.createEl("img", {
        attr: {
          src: cover.coverUrl || "",
          alt: cover.title || "Book cover"
        }
      });
      const info = coverItem.createDiv({ cls: "moonsync-cover-info" });
      if (cover.title) {
        info.createDiv({ cls: "moonsync-cover-title", text: cover.title });
      }
      if (cover.author) {
        info.createDiv({ cls: "moonsync-cover-author", text: cover.author });
      }
      if (cover.publishedDate) {
        info.createDiv({ cls: "moonsync-cover-year", text: cover.publishedDate });
      }
      coverItem.addEventListener("click", () => {
        if (cover.coverUrl) {
          this.onSelect(cover.coverUrl);
          this.close();
        }
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SelectBookMetadataModal = class extends import_obsidian3.Modal {
  constructor(app, title, author, onSelect) {
    super(app);
    this.resultsContainer = null;
    this.title = title;
    this.author = author;
    this.onSelect = onSelect;
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-select-cover-modal");
    modalEl.addClass("mod-moonsync-cover");
    contentEl.createEl("h2", { text: "Fetch Book Metadata" });
    contentEl.createEl("p", {
      text: "Select a book to replace all metadata including cover, description, and details.",
      cls: "moonsync-url-description"
    });
    const titleSetting = new import_obsidian3.Setting(contentEl).setName("Title").addText((text) => {
      text.setPlaceholder("Enter book title").setValue(this.title).onChange((value) => {
        this.title = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          this.performSearch();
        }
      });
    });
    titleSetting.settingEl.addClass("moonsync-labeled-field");
    const authorSetting = new import_obsidian3.Setting(contentEl).setName("Author").addText((text) => {
      text.setPlaceholder("Enter author name").setValue(this.author).onChange((value) => {
        this.author = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          this.performSearch();
        }
      });
    });
    authorSetting.settingEl.addClass("moonsync-labeled-field");
    new import_obsidian3.Setting(contentEl).addButton((button) => {
      button.setButtonText("Search").setCta().onClick(() => this.performSearch());
    });
    this.resultsContainer = contentEl.createDiv({ cls: "moonsync-cover-results" });
    setTimeout(() => this.performSearch(), 150);
  }
  async performSearch() {
    if (!this.resultsContainer)
      return;
    this.resultsContainer.empty();
    if (!this.title.trim()) {
      this.resultsContainer.createEl("p", {
        text: "Please enter a book title.",
        cls: "setting-item-description"
      });
      return;
    }
    const loadingEl = this.resultsContainer.createDiv({ cls: "moonsync-loading" });
    loadingEl.setText("Searching for books...");
    const books = await fetchMultipleBookCovers(this.title, this.author, 10);
    loadingEl.remove();
    if (books.length === 0) {
      this.resultsContainer.createEl("p", {
        text: "No books found. Try a different search query.",
        cls: "setting-item-description"
      });
      return;
    }
    this.resultsContainer.createEl("p", {
      text: `Found ${books.length} result${books.length === 1 ? "" : "s"} for "${this.title}"${this.author ? ` by ${this.author}` : ""}`,
      cls: "moonsync-search-info"
    });
    const gridContainer = this.resultsContainer.createDiv({ cls: "moonsync-cover-grid" });
    for (const book of books) {
      const bookItem = gridContainer.createDiv({ cls: "moonsync-cover-item" });
      if (book.coverUrl) {
        bookItem.createEl("img", {
          attr: {
            src: book.coverUrl,
            alt: book.title || "Book cover"
          }
        });
      }
      const info = bookItem.createDiv({ cls: "moonsync-cover-info" });
      if (book.title) {
        info.createDiv({ cls: "moonsync-cover-title", text: book.title });
      }
      if (book.author) {
        info.createDiv({ cls: "moonsync-cover-author", text: book.author });
      }
      const details = [];
      if (book.publishedDate) {
        details.push(book.publishedDate);
      }
      if (book.publisher) {
        details.push(book.publisher);
      }
      if (book.pageCount) {
        details.push(`${book.pageCount} pages`);
      }
      if (details.length > 0) {
        info.createDiv({ cls: "moonsync-cover-year", text: details.join(" \xB7 ") });
      }
      bookItem.addEventListener("click", () => {
        this.onSelect(book);
        this.close();
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CreateBookModal = class extends import_obsidian3.Modal {
  constructor(app, settings, onSubmit) {
    super(app);
    this.title = "";
    this.author = "";
    this.resultsContainer = null;
    this.settings = settings;
    this.onSubmit = onSubmit;
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-select-cover-modal");
    modalEl.addClass("mod-moonsync-cover");
    contentEl.createEl("h2", { text: "Create Book Note" });
    contentEl.createEl("p", {
      text: "Search for a book and select it to create a note.",
      cls: "moonsync-url-description"
    });
    const titleSetting = new import_obsidian3.Setting(contentEl).setName("Title").addText((text) => {
      text.setPlaceholder("Enter book title").setValue(this.title).onChange((value) => {
        this.title = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          this.performSearch();
        }
      });
    });
    titleSetting.settingEl.addClass("moonsync-labeled-field");
    const authorSetting = new import_obsidian3.Setting(contentEl).setName("Author").addText((text) => {
      text.setPlaceholder("Enter author name (optional)").setValue(this.author).onChange((value) => {
        this.author = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          this.performSearch();
        }
      });
    });
    authorSetting.settingEl.addClass("moonsync-labeled-field");
    new import_obsidian3.Setting(contentEl).addButton((button) => {
      button.setButtonText("Search").setCta().onClick(() => this.performSearch());
    });
    this.resultsContainer = contentEl.createDiv({ cls: "moonsync-cover-results" });
  }
  async performSearch() {
    if (!this.resultsContainer)
      return;
    this.resultsContainer.empty();
    if (!this.title.trim()) {
      this.resultsContainer.createEl("p", {
        text: "Please enter a book title.",
        cls: "setting-item-description"
      });
      return;
    }
    const loadingEl = this.resultsContainer.createDiv({ cls: "moonsync-loading" });
    loadingEl.setText("Searching for books...");
    const books = await fetchMultipleBookCovers(this.title, this.author, 10);
    loadingEl.remove();
    if (books.length === 0) {
      this.resultsContainer.createEl("p", {
        text: "No books found. Try a different search query.",
        cls: "setting-item-description"
      });
      return;
    }
    this.resultsContainer.createEl("p", {
      text: `Found ${books.length} result${books.length === 1 ? "" : "s"} for "${this.title}"${this.author ? ` by ${this.author}` : ""}`,
      cls: "moonsync-search-info"
    });
    const gridContainer = this.resultsContainer.createDiv({ cls: "moonsync-cover-grid" });
    for (const book of books) {
      const bookItem = gridContainer.createDiv({ cls: "moonsync-cover-item" });
      if (book.coverUrl) {
        bookItem.createEl("img", {
          attr: {
            src: book.coverUrl,
            alt: book.title || "Book cover"
          }
        });
      }
      const info = bookItem.createDiv({ cls: "moonsync-cover-info" });
      if (book.title) {
        info.createDiv({ cls: "moonsync-cover-title", text: book.title });
      }
      if (book.author) {
        info.createDiv({ cls: "moonsync-cover-author", text: book.author });
      }
      const details = [];
      if (book.publishedDate) {
        details.push(book.publishedDate);
      }
      if (book.publisher) {
        details.push(book.publisher);
      }
      if (book.pageCount) {
        details.push(`${book.pageCount} pages`);
      }
      if (details.length > 0) {
        info.createDiv({ cls: "moonsync-cover-year", text: details.join(" \xB7 ") });
      }
      bookItem.addEventListener("click", () => {
        this.onSubmit(book);
        this.close();
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function generateBookTemplate(title, author, coverPath, description, publishedDate = null, publisher = null, pageCount = null, genres = null, series = null, language = null) {
  const lines = [];
  const escapeYaml3 = (str) => str.replace(/"/g, '\\"').replace(/\n/g, " ");
  lines.push("---");
  lines.push(`title: "${escapeYaml3(title)}"`);
  if (author) {
    lines.push(`author: "${escapeYaml3(author)}"`);
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push("highlights_count: 0");
  lines.push("manual_note: true");
  if (publishedDate) {
    lines.push(`published_date: "${escapeYaml3(publishedDate)}"`);
  }
  if (publisher) {
    lines.push(`publisher: "${escapeYaml3(publisher)}"`);
  }
  if (pageCount !== null) {
    lines.push(`page_count: ${pageCount}`);
  }
  if (genres && genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of genres) {
      lines.push(`  - "${escapeYaml3(genre)}"`);
    }
  }
  if (series) {
    lines.push(`series: "${escapeYaml3(series)}"`);
  }
  if (language) {
    lines.push(`language: "${language}"`);
  }
  if (coverPath) {
    lines.push(`cover: "${coverPath}"`);
  }
  lines.push("---");
  lines.push(`# ${title}`);
  if (author) {
    lines.push(`**Author:** ${author}`);
  }
  lines.push("");
  if (coverPath) {
    lines.push(`![[${coverPath}|200]]`);
    lines.push("");
  }
  if (description) {
    lines.push("## Description");
    lines.push(description);
    lines.push("");
  }
  lines.push("## Highlights");
  lines.push("");
  lines.push("> [!quote]");
  lines.push("> Add your highlights here...");
  lines.push("");
  return lines.join("\n");
}

// src/parser/annotations.ts
var import_promises = require("fs/promises");
var import_path = require("path");
var import_zlib = require("zlib");
function normalizeBookTitle(title, author) {
  let normalized = title.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)$/i, "");
  if (author && normalized.endsWith(` - ${author}`)) {
    normalized = normalized.slice(0, -` - ${author}`.length);
  }
  return normalized.trim();
}
function parseAnnotationFile(data, filename) {
  try {
    const decompressed = (0, import_zlib.inflateSync)(data).toString("utf-8");
    const lines = decompressed.split("\n");
    const baseName = filename.replace(/\.epub\.an$/, "").replace(/\.pdf\.an$/, "");
    const parts = baseName.split(" - ");
    const bookTitle = normalizeBookTitle(parts[0] || baseName);
    const author = parts.length > 1 ? parts.slice(1).join(" - ") : "";
    const highlights = [];
    let i = 0;
    while (i < lines.length && lines[i] !== "#") {
      i++;
    }
    while (i < lines.length) {
      if (lines[i] === "#") {
        i++;
        if (i >= lines.length)
          break;
        const id = parseInt(lines[i++] || "0", 10);
        const title = lines[i++] || "";
        const fullPath = lines[i++] || "";
        const lowerPath = lines[i++] || "";
        const chapter = parseInt(lines[i++] || "0", 10);
        i++;
        const position = parseInt(lines[i++] || "0", 10);
        const length = parseInt(lines[i++] || "0", 10);
        const color = parseInt(lines[i++] || "0", 10);
        const timestamp = parseInt(lines[i++] || "0", 10);
        while (i < lines.length && lines[i] === "") {
          i++;
        }
        let text = "";
        let note = "";
        if (i < lines.length && lines[i] !== "0") {
          const firstLine = lines[i].replace(/<BR>/g, "\n").trim();
          i++;
          if (i < lines.length && lines[i] !== "0" && lines[i] !== "") {
            note = firstLine;
            text = lines[i].replace(/<BR>/g, "\n").trim();
            i++;
          } else {
            text = firstLine;
          }
        }
        while (i < lines.length && (lines[i] === "0" || lines[i] === "")) {
          i++;
        }
        if (text) {
          highlights.push({
            id,
            book: normalizeBookTitle(title, author),
            filename: fullPath,
            chapter,
            position,
            highlightLength: length,
            highlightColor: color,
            timestamp,
            bookmark: "",
            note,
            originalText: text,
            underline: false,
            strikethrough: false
          });
        }
      } else {
        i++;
      }
    }
    return {
      filename,
      bookTitle,
      author,
      highlights
    };
  } catch (error) {
    console.log(`MoonSync: Failed to parse annotation file ${filename}`, error);
    return null;
  }
}
function parseProgressFile(data) {
  try {
    const content = data.toString("utf-8").trim();
    const match = content.match(/^(\d+)\*(\d+)@\d+#\d+:(\d+(?:\.\d+)?)%$/);
    if (match) {
      return {
        timestamp: parseInt(match[1], 10),
        chapter: parseInt(match[2], 10),
        progress: parseFloat(match[3])
      };
    }
  } catch (e) {
  }
  return null;
}
async function parseAnnotationFiles(dropboxPath, trackBooksWithoutHighlights = false) {
  var _a, _b;
  const cacheDir = (0, import_path.join)(dropboxPath, ".Moon+", "Cache");
  const bookDataMap = /* @__PURE__ */ new Map();
  try {
    const files = await (0, import_promises.readdir)(cacheDir);
    const anFiles = files.filter((f) => f.endsWith(".an"));
    for (const anFile of anFiles) {
      try {
        const filePath = (0, import_path.join)(cacheDir, anFile);
        const data = await (0, import_promises.readFile)(filePath);
        const parsed = parseAnnotationFile(data, anFile);
        if (parsed && parsed.highlights.length > 0) {
          const actualTitle = ((_a = parsed.highlights[0]) == null ? void 0 : _a.book) || parsed.bookTitle;
          const key = actualTitle.toLowerCase();
          if (!bookDataMap.has(key)) {
            const book = {
              id: 0,
              title: actualTitle,
              filename: ((_b = parsed.highlights[0]) == null ? void 0 : _b.filename) || "",
              author: parsed.author,
              description: "",
              category: "",
              thumbFile: "",
              coverFile: "",
              addTime: "",
              favorite: ""
            };
            bookDataMap.set(key, {
              book,
              highlights: [],
              statistics: null,
              progress: null,
              currentChapter: null,
              lastReadTimestamp: null,
              coverPath: null,
              fetchedDescription: null,
              publishedDate: null,
              publisher: null,
              pageCount: null,
              genres: null,
              series: null,
              isbn10: null,
              isbn13: null,
              language: null
            });
          }
          const bookData = bookDataMap.get(key);
          bookData.highlights.push(...parsed.highlights);
        }
      } catch (error) {
        console.log(`MoonSync: Error reading ${anFile}`, error);
      }
    }
    const poFiles = files.filter((f) => f.endsWith(".po"));
    for (const poFile of poFiles) {
      try {
        const baseName = poFile.replace(/\.epub\.po$/, "").replace(/\.pdf\.po$/, "");
        const parts = baseName.split(" - ");
        let bookTitle = parts[0] || baseName;
        const author = parts.length > 1 ? parts.slice(1).join(" - ") : "";
        if (!bookTitle.includes(" ") && bookTitle.includes("_")) {
          bookTitle = bookTitle.replace(/_/g, " ");
        }
        const key = bookTitle.toLowerCase();
        const filePath = (0, import_path.join)(cacheDir, poFile);
        const data = await (0, import_promises.readFile)(filePath);
        const progressData = parseProgressFile(data);
        if (bookDataMap.has(key)) {
          if (progressData !== null) {
            const bookData = bookDataMap.get(key);
            bookData.progress = progressData.progress;
            bookData.currentChapter = progressData.chapter;
            bookData.lastReadTimestamp = progressData.timestamp;
          }
        } else if (trackBooksWithoutHighlights && progressData !== null) {
          const book = {
            id: 0,
            title: bookTitle,
            filename: baseName,
            author,
            description: "",
            category: "",
            thumbFile: "",
            coverFile: "",
            addTime: "",
            favorite: ""
          };
          bookDataMap.set(key, {
            book,
            highlights: [],
            statistics: null,
            progress: progressData.progress,
            currentChapter: progressData.chapter,
            lastReadTimestamp: progressData.timestamp,
            coverPath: null,
            fetchedDescription: null,
            publishedDate: null,
            publisher: null,
            pageCount: null,
            genres: null,
            series: null,
            isbn10: null,
            isbn13: null,
            language: null
          });
        }
      } catch (error) {
        console.log(`MoonSync: Error reading ${poFile}`, error);
      }
    }
    for (const bookData of bookDataMap.values()) {
      bookData.highlights.sort((a, b) => a.position - b.position);
    }
    return Array.from(bookDataMap.values());
  } catch (error) {
    console.log("MoonSync: Failed to read Cache directory", error);
    return [];
  }
}

// src/utils.ts
function escapeYaml(str) {
  return str.replace(/"/g, '\\"').replace(/\n/g, " ");
}
function extractFrontmatter(content) {
  if (!content.startsWith("---")) {
    return null;
  }
  const endIndex = content.indexOf("---", 3);
  if (endIndex === -1) {
    return null;
  }
  return content.substring(3, endIndex);
}
function parseFrontmatterField(frontmatter, fieldName) {
  const regex = new RegExp(`^${fieldName}:\\s*"?([^"\\n]+)"?`, "m");
  const match = frontmatter.match(regex);
  return match ? match[1].trim() : null;
}
function parseFrontmatter(content) {
  const frontmatter = extractFrontmatter(content);
  if (!frontmatter) {
    return {
      title: null,
      author: null,
      progress: null,
      highlightsCount: null,
      highlightsHash: null,
      coverPath: null,
      moonReaderPath: null,
      lastSynced: null,
      isManualNote: false,
      hasCustomMetadata: false
    };
  }
  const progressStr = parseFrontmatterField(frontmatter, "progress");
  const highlightsCountStr = parseFrontmatterField(frontmatter, "highlights_count");
  return {
    title: parseFrontmatterField(frontmatter, "title"),
    author: parseFrontmatterField(frontmatter, "author"),
    progress: progressStr ? parseFloat(progressStr) : null,
    highlightsCount: highlightsCountStr ? parseInt(highlightsCountStr, 10) : null,
    highlightsHash: parseFrontmatterField(frontmatter, "highlights_hash"),
    coverPath: parseFrontmatterField(frontmatter, "cover"),
    moonReaderPath: parseFrontmatterField(frontmatter, "moon_reader_path"),
    lastSynced: parseFrontmatterField(frontmatter, "last_synced"),
    isManualNote: /^manual_note:\s*true/m.test(frontmatter),
    hasCustomMetadata: /^custom_metadata:\s*true/m.test(frontmatter)
  };
}
function computeHighlightsHash(highlights) {
  if (highlights.length === 0)
    return "";
  const sorted = [...highlights].sort((a, b) => a.position - b.position);
  const fingerprint = sorted.map((h) => `${h.position}:${h.timestamp}:${h.originalText.length}`).join("|");
  let hash = 5381;
  for (let i = 0; i < fingerprint.length; i++) {
    hash = (hash << 5) + hash + fingerprint.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

// src/writer/markdown.ts
function generateBookNote(bookData, settings) {
  const { book, highlights, statistics, progress, currentChapter, lastReadTimestamp, coverPath, fetchedDescription, publishedDate, publisher, pageCount, genres, series, isbn10, isbn13, language } = bookData;
  const lines = [];
  lines.push("---");
  lines.push(`title: "${escapeYaml(book.title)}"`);
  if (book.author) {
    lines.push(`author: "${escapeYaml(book.author)}"`);
  }
  if (book.category) {
    const category = parseCategory(book.category);
    if (category) {
      lines.push(`category: "${escapeYaml(category)}"`);
    }
  }
  if (progress !== null) {
    lines.push(`progress: ${progress.toFixed(1)}%`);
  }
  if (currentChapter !== null) {
    lines.push(`current_chapter: ${currentChapter}`);
  }
  if (lastReadTimestamp !== null) {
    lines.push(`last_read: ${new Date(lastReadTimestamp).toISOString().split("T")[0]}`);
  }
  if (statistics == null ? void 0 : statistics.usedTime) {
    lines.push(`reading_time: "${formatDuration(statistics.usedTime)}"`);
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push(`moon_reader_path: "${escapeYaml(book.filename)}"`);
  lines.push(`highlights_count: ${highlights.length}`);
  lines.push(`highlights_hash: "${computeHighlightsHash(highlights)}"`);
  const notesCount = highlights.filter((h) => h.note && h.note.trim()).length;
  lines.push(`notes_count: ${notesCount}`);
  if (publishedDate) {
    lines.push(`published_date: "${escapeYaml(publishedDate)}"`);
  }
  if (publisher) {
    lines.push(`publisher: "${escapeYaml(publisher)}"`);
  }
  if (pageCount !== null) {
    lines.push(`page_count: ${pageCount}`);
  }
  if (genres && genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of genres) {
      lines.push(`  - "${escapeYaml(genre)}"`);
    }
  }
  if (series) {
    lines.push(`series: "${escapeYaml(series)}"`);
  }
  if (isbn10) {
    lines.push(`isbn_10: "${isbn10}"`);
  }
  if (isbn13) {
    lines.push(`isbn_13: "${isbn13}"`);
  }
  if (language) {
    lines.push(`language: "${language}"`);
  }
  if (coverPath) {
    lines.push(`cover: "${coverPath}"`);
  }
  lines.push("---");
  lines.push(`# ${book.title}`);
  if (book.author) {
    lines.push(`**Author:** ${book.author}`);
  }
  lines.push("");
  if (coverPath) {
    lines.push(`![[${coverPath}|200]]`);
    lines.push("");
  }
  if (progress !== null || currentChapter !== null || lastReadTimestamp !== null) {
    lines.push("> [!moonsync-reading-progress]+ Reading Progress");
    if (progress !== null) {
      lines.push(`> - **Progress:** ${progress.toFixed(1)}%`);
    }
    if (currentChapter !== null) {
      lines.push(`> - **Chapter:** ${currentChapter}`);
    }
    if (lastReadTimestamp !== null) {
      lines.push(`> - **Last Read:** ${formatDate(lastReadTimestamp)}`);
    }
    lines.push("");
  }
  const description = fetchedDescription || book.description;
  if (description && description.trim().length > 0) {
    lines.push("> [!moonsync-description]+ Description");
    const descLines = description.trim().split("\n");
    for (const line of descLines) {
      lines.push(`> ${line}`);
    }
    lines.push("");
  }
  if (highlights.length > 0) {
    lines.push("## Moon Reader Highlights");
    lines.push("");
    for (const highlight of highlights) {
      lines.push(formatHighlight(highlight, settings.showHighlightColors));
      lines.push("");
    }
  }
  lines.push("## My Notes");
  lines.push("");
  lines.push("> [!moonsync-user-notes]+ Your Notes");
  lines.push("> Add your thoughts, analysis, and notes here. This section is preserved across syncs.");
  lines.push("");
  return lines.join("\n");
}
function formatHighlight(highlight, useColors) {
  const calloutType = useColors ? getCalloutType(highlight.highlightColor) : "quote";
  const dateStr = highlight.timestamp ? formatDate(highlight.timestamp) : "";
  const chapterStr = highlight.chapter > 0 ? `Chapter ${highlight.chapter}` : "";
  const headerParts = [chapterStr, dateStr].filter((p) => p);
  const header = headerParts.length > 0 ? headerParts.join(" \u2022 ") : "";
  const lines = [];
  if (header) {
    lines.push(`> [!${calloutType}] ${header}`);
  } else {
    lines.push(`> [!${calloutType}]`);
  }
  if (highlight.originalText) {
    const text = highlight.originalText.trim();
    const textLines = text.split("\n");
    for (const line of textLines) {
      lines.push(`> ${line}`);
    }
  }
  if (highlight.note && highlight.note.trim()) {
    lines.push(">");
    lines.push(`> ---`);
    lines.push(`> **Note:** ${highlight.note.trim()}`);
  }
  return lines.join("\n");
}
function parseCategory(categoryField) {
  const lines = categoryField.split("\n").map((l) => l.trim()).filter((l) => l && !l.startsWith("<") && !l.startsWith("#"));
  return lines[0] || "";
}
function generateFilename(title) {
  return title.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim().substring(0, 100);
}
function generateIndexNote(books, settings) {
  const lines = [];
  lines.push(`# ${settings.indexNoteTitle}`);
  lines.push("");
  if (settings.showCoverCollage) {
    const booksWithCovers = books.filter((b) => b.coverPath);
    if (booksWithCovers.length > 0) {
      let sortedCovers;
      if (settings.coverCollageSort === "recent") {
        sortedCovers = [...booksWithCovers].sort((a, b) => {
          const aTime = a.lastReadTimestamp || 0;
          const bTime = b.lastReadTimestamp || 0;
          if (bTime !== aTime)
            return bTime - aTime;
          return a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase());
        });
      } else {
        sortedCovers = [...booksWithCovers].sort(
          (a, b) => a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase())
        );
      }
      const coversToShow = settings.coverCollageLimit > 0 ? sortedCovers.slice(0, settings.coverCollageLimit) : sortedCovers;
      const coverImgs = coversToShow.map((book) => {
        const noteFilename = generateFilename(book.book.title);
        return `<a class="internal-link" href="${noteFilename}"><img src="${book.coverPath}" style="height: 120px; width: auto;"></a>`;
      }).join(" ");
      lines.push(coverImgs);
      lines.push("");
    }
  }
  const totalBooks = books.length;
  const totalHighlights = books.reduce((sum, b) => sum + b.highlights.length, 0);
  const totalNotes = books.reduce(
    (sum, b) => sum + b.highlights.filter((h) => h.note && h.note.trim()).length,
    0
  );
  const booksWithProgress = books.filter((b) => b.progress !== null);
  const avgProgress = booksWithProgress.length > 0 ? booksWithProgress.reduce((sum, b) => sum + (b.progress || 0), 0) / booksWithProgress.length : 0;
  lines.push("## Summary");
  lines.push(`- **Books:** ${totalBooks}`);
  lines.push(`- **Highlights:** ${totalHighlights}`);
  lines.push(`- **Notes:** ${totalNotes}`);
  if (booksWithProgress.length > 0) {
    lines.push(`- **Average Progress:** ${avgProgress.toFixed(1)}%`);
  }
  lines.push("");
  lines.push("## Books");
  const sortedBooks = [...books].sort(
    (a, b) => a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase())
  );
  for (const bookData of sortedBooks) {
    const rawFilename = bookData.book.filename;
    const filename = rawFilename && !rawFilename.includes("/") ? rawFilename : generateFilename(bookData.book.title);
    const author = bookData.book.author ? ` by ${bookData.book.author}` : "";
    const progress = bookData.progress !== null ? ` (${bookData.progress.toFixed(0)}%)` : "";
    const highlightCount = bookData.highlights.length;
    const noteCount = bookData.highlights.filter((h) => h.note && h.note.trim()).length;
    const statsText = noteCount > 0 ? `${highlightCount} highlights, ${noteCount} ${noteCount === 1 ? "note" : "notes"}` : `${highlightCount} highlights`;
    lines.push(`- [[${filename}|${bookData.book.title}]]${author}${progress} \u2014 ${statsText}`);
  }
  lines.push("");
  return lines.join("\n");
}
function generateBaseFile(settings) {
  const outputFolder = settings.outputFolder;
  const indexTitle = settings.indexNoteTitle;
  const baseTitle = settings.baseFileName;
  const lines = [];
  lines.push("filters:");
  lines.push("  and:");
  lines.push(`    - file.folder == "${outputFolder}"`);
  lines.push(`    - file.name != "${indexTitle}"`);
  lines.push(`    - file.name != "${baseTitle}"`);
  lines.push('    - file.ext == "md"');
  lines.push("properties:");
  lines.push("  file.name:");
  lines.push("    displayName: Title");
  lines.push("  author:");
  lines.push("    displayName: Author");
  lines.push("  genres:");
  lines.push("    displayName: Genres");
  lines.push("  published_date:");
  lines.push("    displayName: Published");
  lines.push("  page_count:");
  lines.push("    displayName: Pages");
  lines.push("  highlights_count:");
  lines.push("    displayName: Highlights");
  lines.push("  notes_count:");
  lines.push("    displayName: Notes");
  lines.push("  last_synced:");
  lines.push("    displayName: Last Synced");
  lines.push("  last_read:");
  lines.push("    displayName: Last Read");
  lines.push("  publisher:");
  lines.push("    displayName: Publisher");
  lines.push("  series:");
  lines.push("    displayName: Series");
  lines.push("  language:");
  lines.push("    displayName: Language");
  lines.push("  progress:");
  lines.push("    displayName: Progress %");
  lines.push("  manual_note:");
  lines.push("    displayName: Manual");
  lines.push("views:");
  lines.push("  - type: table");
  lines.push("    name: Library");
  lines.push("    order:");
  lines.push("      - file.name");
  lines.push("      - author");
  lines.push("      - highlights_count");
  lines.push("      - progress");
  lines.push("      - notes_count");
  lines.push("      - manual_note");
  lines.push("      - last_read");
  lines.push("      - last_synced");
  lines.push("      - genres");
  lines.push("      - page_count");
  lines.push("      - publisher");
  lines.push("      - published_date");
  lines.push("      - language");
  lines.push("    limit: 100");
  lines.push("    properties:");
  lines.push("      - file.name");
  lines.push("      - note.author");
  lines.push("      - note.genres");
  lines.push("      - note.highlights_count");
  lines.push("      - note.notes_count");
  lines.push("      - note.progress");
  lines.push("      - note.manual_note");
  lines.push("      - note.published_date");
  lines.push("      - note.publisher");
  lines.push("      - note.page_count");
  lines.push("      - note.series");
  lines.push("      - note.language");
  lines.push("      - note.last_read");
  lines.push("      - note.last_synced");
  lines.push("  - type: cards");
  lines.push("    name: Gallery");
  lines.push("    order:");
  lines.push("      - file.name");
  lines.push("    limit: 100");
  lines.push("    image: note.cover");
  lines.push("    imageFit: contain");
  lines.push("    cardSize: medium");
  lines.push("    properties:");
  lines.push("      - file.name");
  lines.push("      - note.author");
  lines.push("      - note.published_date");
  return lines.join("\n");
}

// src/cache.ts
var import_obsidian4 = require("obsidian");
var CACHE_FILE = ".moonsync-cache.json";
function getCacheKey(title, author) {
  return `${title.toLowerCase()}|${author.toLowerCase()}`;
}
async function loadCache(app, outputFolder) {
  const cachePath = (0, import_obsidian4.normalizePath)(`${outputFolder}/${CACHE_FILE}`);
  try {
    if (await app.vault.adapter.exists(cachePath)) {
      const data = await app.vault.adapter.read(cachePath);
      return JSON.parse(data);
    }
  } catch (error) {
    console.log("MoonSync: Failed to load cache, starting fresh", error);
  }
  return {};
}
async function saveCache(app, outputFolder, cache) {
  const cachePath = (0, import_obsidian4.normalizePath)(`${outputFolder}/${CACHE_FILE}`);
  try {
    await app.vault.adapter.write(cachePath, JSON.stringify(cache, null, 2));
  } catch (error) {
    console.log("MoonSync: Failed to save cache", error);
  }
}
function getCachedInfo(cache, title, author) {
  const key = getCacheKey(title, author);
  return cache[key] || null;
}
function setCachedInfo(cache, title, author, info) {
  const key = getCacheKey(title, author);
  cache[key] = {
    ...info,
    fetchedAt: Date.now()
  };
}

// src/scanner.ts
var import_obsidian5 = require("obsidian");
async function scanAllBookNotes(app, outputPath) {
  const books = [];
  const normalizedPath = (0, import_obsidian5.normalizePath)(outputPath);
  if (!await app.vault.adapter.exists(normalizedPath)) {
    return books;
  }
  const listing = await app.vault.adapter.list(normalizedPath);
  for (const filePath of listing.files) {
    if (!filePath.endsWith(".md"))
      continue;
    try {
      const content = await app.vault.adapter.read(filePath);
      const bookData = parseBookFrontmatter(content, filePath);
      if (bookData) {
        books.push(bookData);
      }
    } catch (error) {
      console.log(`MoonSync: Failed to read ${filePath}`, error);
    }
  }
  return books;
}
function parseBookFrontmatter(content, filePath) {
  var _a;
  const parsed = parseFrontmatter(content);
  if (!parsed.title) {
    return null;
  }
  const notesCount = (content.match(/\*\*Note:\*\*/g) || []).length;
  let lastReadTimestamp = null;
  if (parsed.lastSynced) {
    lastReadTimestamp = new Date(parsed.lastSynced).getTime();
  }
  return {
    title: parsed.title,
    author: parsed.author,
    progress: parsed.progress,
    highlightsCount: (_a = parsed.highlightsCount) != null ? _a : 0,
    notesCount,
    coverPath: parsed.coverPath,
    lastReadTimestamp,
    filePath,
    isMoonReader: !!parsed.moonReaderPath
  };
}
function scannedBookToBookData(scanned) {
  const filenameWithExt = scanned.filePath.split("/").pop() || "";
  const actualFilename = filenameWithExt.replace(/\.md$/, "");
  const book = {
    id: 0,
    title: scanned.title,
    filename: actualFilename,
    // Store actual filename for index links
    author: scanned.author || "",
    description: "",
    category: "",
    thumbFile: "",
    coverFile: "",
    addTime: "",
    favorite: ""
  };
  const highlights = [];
  for (let i = 0; i < scanned.highlightsCount; i++) {
    highlights.push({
      id: i,
      book: scanned.title,
      filename: "",
      chapter: 0,
      position: 0,
      highlightLength: 0,
      highlightColor: 0,
      timestamp: 0,
      bookmark: "",
      note: i < scanned.notesCount ? "note" : "",
      // Mark first N as having notes
      originalText: "",
      underline: false,
      strikethrough: false
    });
  }
  return {
    book,
    highlights,
    statistics: null,
    progress: scanned.progress,
    currentChapter: null,
    lastReadTimestamp: scanned.lastReadTimestamp,
    coverPath: scanned.coverPath,
    fetchedDescription: null,
    publishedDate: null,
    publisher: null,
    pageCount: null,
    genres: null,
    series: null,
    isbn10: null,
    isbn13: null,
    language: null
  };
}
function mergeBookLists(moonReaderBooks, scannedBooks) {
  const result = [...moonReaderBooks];
  const moonReaderMap = /* @__PURE__ */ new Map();
  for (const book of result) {
    moonReaderMap.set(book.book.title.toLowerCase(), book);
  }
  function findMoonReaderBook(scannedTitle) {
    const scannedLower = scannedTitle.toLowerCase();
    const exactMatch = moonReaderMap.get(scannedLower);
    if (exactMatch)
      return exactMatch;
    for (const [moonTitle, book] of moonReaderMap) {
      if (scannedLower.startsWith(moonTitle) || moonTitle.startsWith(scannedLower)) {
        return book;
      }
    }
    return void 0;
  }
  for (const scanned of scannedBooks) {
    const moonReaderBook = findMoonReaderBook(scanned.title);
    if (moonReaderBook) {
      const filenameWithExt = scanned.filePath.split("/").pop() || "";
      const actualFilename = filenameWithExt.replace(/\.md$/, "");
      moonReaderBook.book.filename = actualFilename;
      moonReaderBook.book.title = scanned.title;
      if (scanned.coverPath) {
        moonReaderBook.coverPath = scanned.coverPath;
      }
    } else {
      result.push(scannedBookToBookData(scanned));
    }
  }
  return result;
}

// src/sync.ts
async function syncFromMoonReader(app, settings, wasmPath) {
  const result = {
    success: false,
    booksProcessed: 0,
    booksCreated: 0,
    booksUpdated: 0,
    booksSkipped: 0,
    manualBooksAdded: 0,
    totalHighlights: 0,
    totalNotes: 0,
    isFirstSync: false,
    errors: [],
    failedBooks: []
  };
  const progressNotice = new import_obsidian6.Notice("MoonSync: Syncing...", 0);
  try {
    if (!settings.dropboxPath) {
      result.errors.push("Dropbox path not configured");
      progressNotice.hide();
      return result;
    }
    const booksWithHighlights = await parseAnnotationFiles(settings.dropboxPath, settings.trackBooksWithoutHighlights);
    if (booksWithHighlights.length === 0) {
      result.errors.push("No annotation files found in .Moon+/Cache folder");
      progressNotice.hide();
      return result;
    }
    const outputPath = (0, import_obsidian6.normalizePath)(settings.outputFolder);
    const outputFolderExisted = await app.vault.adapter.exists(outputPath);
    result.isFirstSync = !outputFolderExisted;
    if (!outputFolderExisted) {
      await app.vault.createFolder(outputPath);
    }
    result.totalHighlights = booksWithHighlights.reduce((sum, b) => sum + b.highlights.length, 0);
    result.totalNotes = booksWithHighlights.reduce(
      (sum, b) => sum + b.highlights.filter((h) => h.note && h.note.trim()).length,
      0
    );
    const cache = await loadCache(app, outputPath);
    let cacheModified = false;
    progressNotice.setMessage("MoonSync: Scanning existing notes...");
    const titleCache = await buildTitleCache(app, outputPath);
    progressNotice.setMessage("MoonSync: Fetching book metadata...");
    const coversFolder = (0, import_obsidian6.normalizePath)(`${outputPath}/moonsync-covers`);
    let existingCoversSet = /* @__PURE__ */ new Set();
    try {
      if (await app.vault.adapter.exists(coversFolder)) {
        const listing = await app.vault.adapter.list(coversFolder);
        existingCoversSet = new Set(listing.files.map((f) => f.split("/").pop() || ""));
      }
    } catch (e) {
    }
    const booksToFetch = [];
    for (const bookData of booksWithHighlights) {
      const cachedInfo = getCachedInfo(cache, bookData.book.title, bookData.book.author);
      const hasAttemptedFetch = cachedInfo && (cachedInfo.publishedDate !== void 0 && cachedInfo.publisher !== void 0 && cachedInfo.pageCount !== void 0);
      const coverFilename = `${generateFilename(bookData.book.title)}.jpg`;
      const coverExists = existingCoversSet.has(coverFilename);
      if (!coverExists || !hasAttemptedFetch) {
        booksToFetch.push({ title: bookData.book.title, author: bookData.book.author });
      }
    }
    const prefetchedInfo = booksToFetch.length > 0 ? await batchFetchBookInfo(booksToFetch, 5) : /* @__PURE__ */ new Map();
    const totalBooks = booksWithHighlights.length;
    for (let i = 0; i < booksWithHighlights.length; i++) {
      const bookData = booksWithHighlights[i];
      progressNotice.setMessage(`MoonSync: ${bookData.book.title} (${i + 1}/${totalBooks})`);
      try {
        const processed = await processBook(app, outputPath, bookData, settings, result, cache, prefetchedInfo, titleCache);
        if (processed) {
          cacheModified = true;
        }
        result.booksProcessed++;
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        result.failedBooks.push({
          title: bookData.book.title,
          error: errorMsg
        });
        result.errors.push(`Error processing "${bookData.book.title}": ${errorMsg}`);
      }
    }
    const scannedBooks = await scanAllBookNotes(app, outputPath);
    const customBooks = scannedBooks.filter((book) => !book.isMoonReader);
    if (customBooks.length > 0) {
      const totalCustom = customBooks.length;
      for (let i = 0; i < customBooks.length; i++) {
        const customBook = customBooks[i];
        progressNotice.setMessage(`MoonSync: ${customBook.title} (${i + 1}/${totalCustom} custom)`);
        try {
          const processed = await processCustomBook(app, outputPath, customBook, settings, result, cache);
          if (processed) {
            cacheModified = true;
          }
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          result.failedBooks.push({
            title: customBook.title,
            error: errorMsg
          });
          result.errors.push(`Error processing custom book "${customBook.title}": ${errorMsg}`);
        }
      }
    }
    if (cacheModified) {
      await saveCache(app, outputPath, cache);
    }
    if (settings.showIndex) {
      const indexPath = (0, import_obsidian6.normalizePath)(`${outputPath}/${settings.indexNoteTitle}.md`);
      const indexExists = await app.vault.adapter.exists(indexPath);
      const indexFilename = `${settings.indexNoteTitle}.md`;
      const filteredScanned = scannedBooks.filter((b) => !b.filePath.endsWith(indexFilename));
      const totalBookNotes = filteredScanned.length;
      const manualBookCount = totalBookNotes - booksWithHighlights.length;
      const hasManualBooks = manualBookCount > 0;
      if (hasManualBooks) {
        result.manualBooksAdded = manualBookCount;
      }
      if (result.booksCreated > 0 || result.booksUpdated > 0 || !indexExists || hasManualBooks) {
        const coversFolder2 = (0, import_obsidian6.normalizePath)(`${outputPath}/moonsync-covers`);
        let existingCovers = /* @__PURE__ */ new Set();
        try {
          if (await app.vault.adapter.exists(coversFolder2)) {
            const listing = await app.vault.adapter.list(coversFolder2);
            existingCovers = new Set(listing.files.map((f) => f.split("/").pop() || ""));
          }
        } catch (e) {
        }
        for (const bookData of booksWithHighlights) {
          if (!bookData.coverPath) {
            const coverFilename = `${generateFilename(bookData.book.title)}.jpg`;
            if (existingCovers.has(coverFilename)) {
              bookData.coverPath = `moonsync-covers/${coverFilename}`;
            }
          }
        }
        await updateIndexNote(app, outputPath, booksWithHighlights, settings);
      }
    }
    if (settings.generateBaseFile) {
      const baseFilePath = (0, import_obsidian6.normalizePath)(`${outputPath}/${settings.baseFileName}.base`);
      const baseExists = await app.vault.adapter.exists(baseFilePath);
      if (result.booksCreated > 0 || result.booksUpdated > 0 || !baseExists) {
        await updateBaseFile(app, outputPath, settings);
      }
    }
    progressNotice.hide();
    result.success = true;
    return result;
  } catch (error) {
    progressNotice.hide();
    result.errors.push(`Sync failed: ${error}`);
    return result;
  }
}
async function getExistingBookData(app, filePath) {
  try {
    if (!await app.vault.adapter.exists(filePath)) {
      return null;
    }
    const content = await app.vault.adapter.read(filePath);
    const parsed = parseFrontmatter(content);
    if (parsed.highlightsCount !== null) {
      return {
        highlightsCount: parsed.highlightsCount,
        highlightsHash: parsed.highlightsHash,
        progress: parsed.progress,
        isManualNote: parsed.isManualNote,
        hasCustomMetadata: parsed.hasCustomMetadata,
        fullContent: content
      };
    }
  } catch (e) {
  }
  return null;
}
function mergeManualNoteWithMoonReader(existingContent, bookData, settings) {
  const lines = [];
  const frontmatterMatch = existingContent.match(/^---\n([\s\S]*?)\n---/);
  const contentAfterFrontmatter = frontmatterMatch ? existingContent.slice(frontmatterMatch[0].length).trim() : existingContent.trim();
  lines.push("---");
  if (frontmatterMatch) {
    const frontmatter = frontmatterMatch[1];
    const frontmatterLines = frontmatter.split("\n");
    for (const line of frontmatterLines) {
      if (line.startsWith("progress:") || line.startsWith("current_chapter:") || line.startsWith("highlights_count:") || line.startsWith("highlights_hash:") || line.startsWith("notes_count:") || line.startsWith("last_synced:") || line.startsWith("manual_note:") || line.startsWith("published_date:") || line.startsWith("publisher:") || line.startsWith("page_count:") || line.startsWith("genres:") || line.startsWith("series:") || line.startsWith("language:") || line.trim().startsWith("-")) {
        continue;
      }
      lines.push(line);
    }
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push(`highlights_count: ${bookData.highlights.length}`);
  lines.push(`highlights_hash: "${computeHighlightsHash(bookData.highlights)}"`);
  const notesCount = bookData.highlights.filter((h) => h.note && h.note.trim()).length;
  lines.push(`notes_count: ${notesCount}`);
  if (settings.showProgress && bookData.progress !== null) {
    lines.push(`progress: "${bookData.progress.toFixed(1)}%"`);
    if (bookData.currentChapter) {
      lines.push(`current_chapter: ${bookData.currentChapter}`);
    }
  }
  if (bookData.publishedDate) {
    lines.push(`published_date: "${bookData.publishedDate.replace(/"/g, '\\"')}"`);
  }
  if (bookData.publisher) {
    lines.push(`publisher: "${bookData.publisher.replace(/"/g, '\\"')}"`);
  }
  if (bookData.pageCount !== null) {
    lines.push(`page_count: ${bookData.pageCount}`);
  }
  if (bookData.genres && bookData.genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of bookData.genres) {
      lines.push(`  - "${genre.replace(/"/g, '\\"')}"`);
    }
  }
  if (bookData.series) {
    lines.push(`series: "${bookData.series.replace(/"/g, '\\"')}"`);
  }
  if (bookData.language) {
    lines.push(`language: "${bookData.language}"`);
  }
  lines.push("---");
  lines.push("");
  lines.push(contentAfterFrontmatter);
  lines.push("");
  lines.push("## Moon Reader Highlights");
  lines.push("");
  if (settings.showReadingProgress && (bookData.progress !== null || bookData.currentChapter !== null)) {
    lines.push("**Reading Progress:**");
    if (bookData.progress !== null) {
      lines.push(`- Progress: ${bookData.progress.toFixed(1)}%`);
    }
    if (bookData.currentChapter !== null) {
      lines.push(`- Chapter: ${bookData.currentChapter}`);
    }
    lines.push("");
  }
  for (const highlight of bookData.highlights) {
    lines.push(formatHighlight(highlight, settings.showHighlightColors));
    lines.push("");
  }
  return lines.join("\n");
}
function mergeExistingNoteWithHighlights(existingContent, bookData, settings) {
  const myNotesPattern = /\n## My Notes\n([\s\S]*?)(?=\n## |\n---|\s*$)/;
  const myNotesMatch = existingContent.match(myNotesPattern);
  let userNotesContent = "";
  if (myNotesMatch) {
    let notesSection = myNotesMatch[1];
    const placeholderPattern = /^> \[!moonsync-user-notes\]\+ Your Notes\n> Add your thoughts, analysis, and notes here\. This section is preserved across syncs\.\n?/;
    notesSection = notesSection.replace(placeholderPattern, "").trim();
    if (notesSection) {
      userNotesContent = notesSection;
    }
  }
  let freshNote = generateBookNote(bookData, settings);
  if (userNotesContent) {
    const placeholderInFresh = "> [!moonsync-user-notes]+ Your Notes\n> Add your thoughts, analysis, and notes here. This section is preserved across syncs.";
    freshNote = freshNote.replace(placeholderInFresh, userNotesContent);
  }
  return freshNote;
}
function calculateSimilarity(str1, str2) {
  const s1 = str1.toLowerCase();
  const s2 = str2.toLowerCase();
  if (s1 === s2)
    return 1;
  const len1 = s1.length;
  const len2 = s2.length;
  if (len1 === 0)
    return len2 === 0 ? 1 : 0;
  if (len2 === 0)
    return 0;
  const matrix = [];
  for (let i = 0; i <= len1; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= len2; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        // deletion
        matrix[i][j - 1] + 1,
        // insertion
        matrix[i - 1][j - 1] + cost
        // substitution
      );
    }
  }
  const distance = matrix[len1][len2];
  const maxLen = Math.max(len1, len2);
  return 1 - distance / maxLen;
}
function normalizeBookTitle2(title) {
  return title.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)$/i, "").trim();
}
async function buildTitleCache(app, outputPath) {
  const cache = [];
  try {
    const listing = await app.vault.adapter.list((0, import_obsidian6.normalizePath)(outputPath));
    for (const filePath of listing.files) {
      if (!filePath.endsWith(".md"))
        continue;
      try {
        const content = await app.vault.adapter.read(filePath);
        const parsed = parseFrontmatter(content);
        if (parsed.title) {
          cache.push({
            normalizedTitle: normalizeBookTitle2(parsed.title),
            filePath
          });
        }
      } catch (e) {
      }
    }
  } catch (e) {
  }
  return cache;
}
var SIMILARITY_THRESHOLD = 0.8;
async function findExistingFile(app, outputPath, preferredFilename, bookTitle, titleCache) {
  const preferredPath = (0, import_obsidian6.normalizePath)(`${outputPath}/${preferredFilename}.md`);
  if (await app.vault.adapter.exists(preferredPath)) {
    return preferredPath;
  }
  const normalizedBookTitle = normalizeBookTitle2(bookTitle);
  let bestMatch = null;
  for (const entry of titleCache) {
    const similarity = calculateSimilarity(normalizedBookTitle, entry.normalizedTitle);
    if (similarity >= SIMILARITY_THRESHOLD) {
      if (!bestMatch || similarity > bestMatch.similarity) {
        bestMatch = { path: entry.filePath, similarity };
      }
    }
  }
  if (bestMatch) {
    console.log(`Best match: "${bestMatch.path}" (${(bestMatch.similarity * 100).toFixed(1)}%)`);
    if (bestMatch.path !== preferredPath) {
      try {
        await app.vault.adapter.rename(bestMatch.path, preferredPath);
        return preferredPath;
      } catch (e) {
        return bestMatch.path;
      }
    }
    return bestMatch.path;
  }
  return preferredPath;
}
async function processBook(app, outputPath, bookData, settings, result, cache, prefetchedInfo = /* @__PURE__ */ new Map(), titleCache = []) {
  const originalTitle = bookData.book.title;
  const originalAuthor = bookData.book.author;
  const filename = generateFilename(bookData.book.title);
  const filePath = await findExistingFile(app, outputPath, filename, bookData.book.title, titleCache);
  let cacheModified = false;
  const cachedInfo = getCachedInfo(cache, originalTitle, originalAuthor);
  const hasAttemptedFetch = cachedInfo && (cachedInfo.publishedDate !== void 0 && cachedInfo.publisher !== void 0 && cachedInfo.pageCount !== void 0 && cachedInfo.genres !== void 0 && cachedInfo.series !== void 0 && cachedInfo.language !== void 0);
  const existingData = await getExistingBookData(app, filePath);
  const fileExists = existingData !== null;
  if (fileExists) {
    const currentHash = computeHighlightsHash(bookData.highlights);
    const highlightsUnchanged = existingData.highlightsHash ? existingData.highlightsHash === currentHash : existingData.highlightsCount === bookData.highlights.length;
    const progressUnchanged = existingData.progress === bookData.progress;
    console.log(`[${bookData.book.title}] Existing hash: ${existingData.highlightsHash || "none"} | New hash: ${currentHash}`);
    console.log(`[${bookData.book.title}] Unchanged: highlights=${highlightsUnchanged}, progress=${progressUnchanged}, hasAttemptedFetch=${hasAttemptedFetch}`);
    if (highlightsUnchanged && progressUnchanged && hasAttemptedFetch) {
      result.booksSkipped++;
      return false;
    }
  }
  const shouldFetchMetadata = true;
  if (shouldFetchMetadata) {
    const coverFilename = `${filename}.jpg`;
    const coversFolder = (0, import_obsidian6.normalizePath)(`${outputPath}/moonsync-covers`);
    const coverPath = (0, import_obsidian6.normalizePath)(`${coversFolder}/${coverFilename}`);
    const coverExists = await app.vault.adapter.exists(coverPath);
    if (cachedInfo) {
      if (cachedInfo.description) {
        bookData.fetchedDescription = cachedInfo.description;
      }
      if (!bookData.book.author && cachedInfo.author) {
        bookData.book.author = cachedInfo.author;
      }
      if (cachedInfo.publishedDate) {
        bookData.publishedDate = cachedInfo.publishedDate;
      }
      if (cachedInfo.publisher) {
        bookData.publisher = cachedInfo.publisher;
      }
      if (cachedInfo.pageCount !== null) {
        bookData.pageCount = cachedInfo.pageCount;
      }
      if (cachedInfo.genres) {
        bookData.genres = cachedInfo.genres;
      }
      if (cachedInfo.series) {
        bookData.series = cachedInfo.series;
      }
      if (cachedInfo.language) {
        bookData.language = cachedInfo.language;
      }
    }
    const prefetchKey = `${bookData.book.title}|${bookData.book.author}`;
    const bookInfo = prefetchedInfo.get(prefetchKey);
    if (bookInfo) {
      if (bookInfo.coverUrl && !coverExists) {
        if (!await app.vault.adapter.exists(coversFolder)) {
          await app.vault.createFolder(coversFolder);
        }
        const imageData = await downloadCover(bookInfo.coverUrl);
        if (imageData) {
          await app.vault.adapter.writeBinary(coverPath, imageData);
          bookData.coverPath = `moonsync-covers/${coverFilename}`;
        }
      }
      if (bookInfo.description) {
        bookData.fetchedDescription = bookInfo.description;
      }
      if (!bookData.book.author && bookInfo.author) {
        bookData.book.author = bookInfo.author;
      }
      if (bookInfo.publishedDate) {
        bookData.publishedDate = bookInfo.publishedDate;
      }
      if (bookInfo.publisher) {
        bookData.publisher = bookInfo.publisher;
      }
      if (bookInfo.pageCount !== null) {
        bookData.pageCount = bookInfo.pageCount;
      }
      if (bookInfo.genres) {
        bookData.genres = bookInfo.genres;
      }
      if (bookInfo.series) {
        bookData.series = bookInfo.series;
      }
      if (bookInfo.language) {
        bookData.language = bookInfo.language;
      }
      setCachedInfo(cache, originalTitle, originalAuthor, {
        title: originalTitle,
        description: bookInfo.description,
        author: bookInfo.author,
        publishedDate: bookInfo.publishedDate,
        publisher: bookInfo.publisher,
        pageCount: bookInfo.pageCount,
        genres: bookInfo.genres,
        series: bookInfo.series,
        language: bookInfo.language
      });
      cacheModified = true;
    }
    if (coverExists) {
      bookData.coverPath = `moonsync-covers/${coverFilename}`;
    }
  }
  let markdown;
  if (fileExists && existingData.isManualNote) {
    markdown = mergeManualNoteWithMoonReader(existingData.fullContent, bookData, settings);
  } else if (fileExists) {
    markdown = mergeExistingNoteWithHighlights(existingData.fullContent, bookData, settings);
  } else {
    markdown = generateBookNote(bookData, settings);
  }
  if (fileExists) {
    await app.vault.adapter.write(filePath, markdown);
    result.booksUpdated++;
  } else {
    await app.vault.create(filePath, markdown);
    result.booksCreated++;
  }
  return cacheModified;
}
async function processCustomBook(app, outputPath, scannedBook, settings, result, cache) {
  let cacheModified = false;
  try {
    const content = await app.vault.adapter.read(scannedBook.filePath);
    if (/^custom_metadata:\s*true/m.test(content)) {
      return false;
    }
  } catch (e) {
  }
  const cachedInfo = getCachedInfo(cache, scannedBook.title, scannedBook.author || "");
  if (cachedInfo && cachedInfo.publishedDate !== void 0 && cachedInfo.publisher !== void 0 && cachedInfo.pageCount !== void 0 && cachedInfo.genres !== void 0 && cachedInfo.series !== void 0 && cachedInfo.language !== void 0) {
    return false;
  }
  const author = scannedBook.author || "Unknown";
  const bookInfo = await fetchBookInfo(scannedBook.title, author);
  if (bookInfo.coverUrl || bookInfo.description || bookInfo.publishedDate || bookInfo.publisher || bookInfo.pageCount !== null || bookInfo.genres || bookInfo.series || bookInfo.language) {
    const content = await app.vault.adapter.read(scannedBook.filePath);
    const updatedContent = updateCustomBookFrontmatter(content, bookInfo, settings);
    await app.vault.adapter.write(scannedBook.filePath, updatedContent);
    setCachedInfo(cache, scannedBook.title, scannedBook.author, {
      title: bookInfo.title,
      // Canonical title from Google Books/Open Library
      description: bookInfo.description,
      author: bookInfo.author,
      publishedDate: bookInfo.publishedDate,
      publisher: bookInfo.publisher,
      pageCount: bookInfo.pageCount,
      genres: bookInfo.genres,
      series: bookInfo.series,
      language: bookInfo.language
    });
    cacheModified = true;
    result.booksUpdated++;
    if (bookInfo.coverUrl) {
      const coverFilename = `${generateFilename(scannedBook.title)}.jpg`;
      const coversFolder = (0, import_obsidian6.normalizePath)(`${outputPath}/moonsync-covers`);
      const coverPath = (0, import_obsidian6.normalizePath)(`${coversFolder}/${coverFilename}`);
      if (!await app.vault.adapter.exists(coverPath)) {
        if (!await app.vault.adapter.exists(coversFolder)) {
          await app.vault.createFolder(coversFolder);
        }
        const imageData = await downloadCover(bookInfo.coverUrl);
        if (imageData) {
          await app.vault.adapter.writeBinary(coverPath, imageData);
        }
      }
    }
  }
  return cacheModified;
}
function updateCustomBookFrontmatter(content, bookInfo, settings) {
  var _a, _b;
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    return content;
  }
  const frontmatter = frontmatterMatch[1];
  const contentAfterFrontmatter = content.slice(frontmatterMatch[0].length);
  const lines = [];
  lines.push("---");
  const frontmatterLines = frontmatter.split("\n");
  let skipNextLine = false;
  for (const line of frontmatterLines) {
    if (skipNextLine && line.trim().startsWith("-")) {
      continue;
    }
    skipNextLine = false;
    if (line.startsWith("published_date:") || line.startsWith("publisher:") || line.startsWith("page_count:") || line.startsWith("genres:") || line.startsWith("series:") || line.startsWith("language:") || line.startsWith("cover:")) {
      if (line.startsWith("genres:")) {
        skipNextLine = true;
      }
      continue;
    }
    lines.push(line);
  }
  if (bookInfo.publishedDate) {
    lines.push(`published_date: "${escapeYaml2(bookInfo.publishedDate)}"`);
  }
  if (bookInfo.publisher) {
    lines.push(`publisher: "${escapeYaml2(bookInfo.publisher)}"`);
  }
  if (bookInfo.pageCount !== null) {
    lines.push(`page_count: ${bookInfo.pageCount}`);
  }
  if (bookInfo.genres && bookInfo.genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of bookInfo.genres) {
      lines.push(`  - "${escapeYaml2(genre)}"`);
    }
  }
  if (bookInfo.series) {
    lines.push(`series: "${escapeYaml2(bookInfo.series)}"`);
  }
  if (bookInfo.language) {
    lines.push(`language: "${bookInfo.language}"`);
  }
  const coverFilename = generateFilename(((_b = (_a = frontmatterLines.find((l) => l.startsWith("title:"))) == null ? void 0 : _a.split(":")[1]) == null ? void 0 : _b.trim().replace(/"/g, "")) || "");
  if (coverFilename) {
    lines.push(`cover: "moonsync-covers/${coverFilename}.jpg"`);
  }
  lines.push("---");
  return lines.join("\n") + contentAfterFrontmatter;
}
function escapeYaml2(str) {
  return str.replace(/"/g, '\\"').replace(/\n/g, " ");
}
async function updateIndexNote(app, outputPath, moonReaderBooks, settings) {
  const indexPath = (0, import_obsidian6.normalizePath)(`${outputPath}/${settings.indexNoteTitle}.md`);
  const scannedBooks = await scanAllBookNotes(app, outputPath);
  const indexFilename = `${settings.indexNoteTitle}.md`;
  const filteredScanned = scannedBooks.filter(
    (b) => !b.filePath.endsWith(indexFilename)
  );
  const allBooks = mergeBookLists(moonReaderBooks, filteredScanned);
  const markdown = generateIndexNote(allBooks, settings);
  if (await app.vault.adapter.exists(indexPath)) {
    await app.vault.adapter.write(indexPath, markdown);
  } else {
    await app.vault.create(indexPath, markdown);
  }
}
async function refreshIndexNote(app, settings) {
  if (!settings.showIndex) {
    new import_obsidian6.Notice("MoonSync: Index generation is disabled in settings");
    return;
  }
  const outputPath = (0, import_obsidian6.normalizePath)(settings.outputFolder);
  if (!await app.vault.adapter.exists(outputPath)) {
    new import_obsidian6.Notice("MoonSync: Output folder does not exist");
    return;
  }
  try {
    let moonReaderBooks = [];
    if (settings.dropboxPath) {
      try {
        moonReaderBooks = await parseAnnotationFiles(settings.dropboxPath, settings.trackBooksWithoutHighlights);
      } catch (e) {
      }
    }
    const cache = await loadCache(app, outputPath);
    const coversFolder = (0, import_obsidian6.normalizePath)(`${outputPath}/moonsync-covers`);
    for (const bookData of moonReaderBooks) {
      if (!bookData.coverPath) {
        const coverFilename = `${generateFilename(bookData.book.title)}.jpg`;
        const coverPath = (0, import_obsidian6.normalizePath)(`${coversFolder}/${coverFilename}`);
        if (await app.vault.adapter.exists(coverPath)) {
          bookData.coverPath = `moonsync-covers/${coverFilename}`;
        }
      }
    }
    await updateIndexNote(app, outputPath, moonReaderBooks, settings);
    new import_obsidian6.Notice("MoonSync: Index refreshed");
  } catch (error) {
    console.error("MoonSync: Failed to refresh index", error);
    new import_obsidian6.Notice("MoonSync: Failed to refresh index");
  }
}
async function updateBaseFile(app, outputPath, settings) {
  const baseFilePath = (0, import_obsidian6.normalizePath)(`${outputPath}/${settings.baseFileName}.base`);
  const content = generateBaseFile(settings);
  if (await app.vault.adapter.exists(baseFilePath)) {
    await app.vault.adapter.write(baseFilePath, content);
  } else {
    await app.vault.create(baseFilePath, content);
  }
}
async function refreshBaseFile(app, settings) {
  if (!settings.generateBaseFile) {
    new import_obsidian6.Notice("MoonSync: Base file generation is disabled in settings");
    return;
  }
  const outputPath = (0, import_obsidian6.normalizePath)(settings.outputFolder);
  if (!await app.vault.adapter.exists(outputPath)) {
    new import_obsidian6.Notice("MoonSync: Output folder does not exist");
    return;
  }
  try {
    await updateBaseFile(app, outputPath, settings);
    new import_obsidian6.Notice("MoonSync: Base file refreshed");
  } catch (error) {
    console.error("MoonSync: Failed to refresh base file", error);
    new import_obsidian6.Notice("MoonSync: Failed to refresh base file");
  }
}
function showSyncResults(app, result, settings) {
  const hasFailedBooks = result.failedBooks && result.failedBooks.length > 0;
  if (result.success) {
    if (result.booksProcessed === 0 && !hasFailedBooks) {
      new import_obsidian6.Notice("MoonSync: No books with highlights to sync");
    } else if (result.isFirstSync || hasFailedBooks) {
      new SyncSummaryModal(app, result, settings).open();
    } else {
      const totalProcessed = result.booksCreated + result.booksUpdated;
      const totalBooks = totalProcessed + result.booksSkipped + result.manualBooksAdded;
      if (totalProcessed === 0) {
        new import_obsidian6.Notice("MoonSync: All books up to date");
      } else {
        new import_obsidian6.Notice(`MoonSync: Updated ${totalProcessed} of ${totalBooks} books`);
      }
    }
  } else {
    new import_obsidian6.Notice(`MoonSync: Sync failed - ${result.errors[0]}`);
  }
  for (const error of result.errors) {
    console.error("MoonSync:", error);
  }
}

// src/parser/manual-export.ts
function parseManualExport(content) {
  const lines = content.split("\n");
  if (lines.length === 0) {
    return null;
  }
  const headerMatch = lines[0].match(/^(.+?)\s+-\s+(.+?)\s+\(Highlight:\s+\d+;\s+Note:\s+\d+\)$/);
  if (!headerMatch) {
    return null;
  }
  const title = headerMatch[1].trim();
  const author = headerMatch[2].trim();
  const highlights = [];
  let currentChapter = 0;
  let chapterName = "";
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line || line.startsWith("\u2500\u2500\u2500")) {
      continue;
    }
    if (line.startsWith("\u25C6")) {
      chapterName = line.substring(1).trim();
      const chapterMatch = chapterName.match(/Chapter\s+(\d+)/i);
      if (chapterMatch) {
        currentChapter = parseInt(chapterMatch[1]);
      } else {
        currentChapter++;
      }
      continue;
    }
    if (line.startsWith("\u25AA")) {
      let highlightText = line.substring(1).trim();
      let noteText = "";
      const noteMatch = highlightText.match(/^(.*?)\s+\((.+)\)$/);
      if (noteMatch) {
        highlightText = noteMatch[1].trim();
        noteText = noteMatch[2].trim();
      }
      highlights.push({
        originalText: highlightText,
        note: noteText,
        chapter: currentChapter,
        highlightColor: -256,
        // Yellow (default)
        timestamp: Date.now(),
        pagePos: 0,
        rangeStart: "",
        rangeEnd: ""
      });
    }
  }
  return {
    title,
    author,
    highlights
  };
}

// main.ts
var import_path2 = require("path");
var MoonSyncPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.ribbonIconEl = null;
    this.styleEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new MoonSyncSettingTab(this.app, this));
    this.updateRibbonIcon();
    this.updateContentVisibility();
    this.addCommand({
      id: "sync-now",
      name: "Sync Now",
      callback: () => this.runSync()
    });
    this.addCommand({
      id: "create-book-note",
      name: "Create Book Note",
      callback: () => this.openCreateBookModal()
    });
    this.addCommand({
      id: "import-note",
      name: "Import Note",
      callback: () => this.importManualExport()
    });
    this.addCommand({
      id: "refetch-cover",
      name: "Fetch Book Cover",
      callback: () => this.refetchBookCover()
    });
    this.addCommand({
      id: "fetch-metadata",
      name: "Fetch Book Metadata",
      callback: () => this.fetchBookMetadata()
    });
    if (this.settings.syncOnStartup) {
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => this.runSync(), 2e3);
      });
    }
  }
  onunload() {
    if (this.styleEl) {
      this.styleEl.remove();
      this.styleEl = null;
    }
  }
  updateRibbonIcon() {
    if (this.ribbonIconEl) {
      this.ribbonIconEl.remove();
      this.ribbonIconEl = null;
    }
    if (this.settings.showRibbonIcon) {
      this.ribbonIconEl = this.addRibbonIcon(
        "book-open",
        "MoonSync: Sync Now",
        () => this.runSync()
      );
    }
  }
  updateContentVisibility() {
    if (this.styleEl) {
      this.styleEl.remove();
      this.styleEl = null;
    }
    this.styleEl = document.createElement("style");
    this.styleEl.id = "moonsync-content-visibility";
    const rules = [];
    rules.push(`.callout[data-callout="moonsync-reading-progress"] { --callout-color: var(--callout-success); }`);
    rules.push(`.callout[data-callout="moonsync-description"] { --callout-color: var(--callout-quote); }`);
    rules.push(`.callout[data-callout="moonsync-user-notes"] { --callout-color: 168, 130, 255; }`);
    if (!this.settings.showCovers) {
      rules.push(`.internal-embed[src*="moonsync-covers/"] { display: none !important; }`);
    }
    if (!this.settings.showReadingProgress) {
      rules.push(`.callout[data-callout="moonsync-reading-progress"] { display: none !important; }`);
    }
    if (!this.settings.showDescription) {
      rules.push(`.callout[data-callout="moonsync-description"] { display: none !important; }`);
    }
    if (!this.settings.showHighlightColors) {
      rules.push(`.callout[data-callout="info"], .callout[data-callout="tip"], .callout[data-callout="warning"] { --callout-color: var(--callout-quote); }`);
    }
    this.styleEl.textContent = rules.join("\n");
    document.head.appendChild(this.styleEl);
  }
  async runSync() {
    if (!this.settings.dropboxPath) {
      new import_obsidian7.Notice("MoonSync: Please configure the Dropbox path in settings");
      return;
    }
    try {
      const wasmPath = this.getWasmPath();
      const result = await syncFromMoonReader(
        this.app,
        this.settings,
        wasmPath
      );
      showSyncResults(this.app, result, this.settings);
    } catch (error) {
      console.error("MoonSync sync error:", error);
      new import_obsidian7.Notice(`MoonSync: Sync failed - ${error}`);
    }
  }
  /**
   * Get the path to the sql-wasm.wasm file bundled with the plugin
   */
  getWasmPath() {
    const pluginDir = this.app.vault.adapter.basePath;
    const pluginPath = this.manifest.dir;
    if (pluginPath) {
      return (0, import_path2.join)(pluginDir, pluginPath, "sql-wasm.wasm");
    }
    throw new Error("Could not determine plugin directory");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Open the modal to create a new book note
   */
  openCreateBookModal() {
    new CreateBookModal(
      this.app,
      this.settings,
      async (bookInfo) => {
        await this.createBookNote(bookInfo);
      }
    ).open();
  }
  /**
   * Create a new book note from selected book info
   */
  async createBookNote(bookInfo) {
    var _a, _b, _c, _d, _e, _f, _g;
    const title = bookInfo.title || "Untitled";
    const progressNotice = new import_obsidian7.Notice("MoonSync: Creating book note...", 0);
    try {
      const outputPath = (0, import_obsidian7.normalizePath)(this.settings.outputFolder);
      const filename = generateFilename(title);
      const filePath = (0, import_obsidian7.normalizePath)(`${outputPath}/${filename}.md`);
      if (await this.app.vault.adapter.exists(filePath)) {
        progressNotice.hide();
        new import_obsidian7.Notice(`MoonSync: A note for "${title}" already exists`);
        return;
      }
      if (!await this.app.vault.adapter.exists(outputPath)) {
        await this.app.vault.createFolder(outputPath);
      }
      let coverPath = null;
      if (bookInfo.coverUrl) {
        try {
          const coversFolder = (0, import_obsidian7.normalizePath)(`${outputPath}/moonsync-covers`);
          if (!await this.app.vault.adapter.exists(coversFolder)) {
            await this.app.vault.createFolder(coversFolder);
          }
          const coverFilename = `${filename}.jpg`;
          const coverFilePath = (0, import_obsidian7.normalizePath)(`${coversFolder}/${coverFilename}`);
          const imageData = await downloadAndResizeCover(bookInfo.coverUrl);
          if (imageData) {
            await this.app.vault.adapter.writeBinary(coverFilePath, imageData);
            coverPath = `moonsync-covers/${coverFilename}`;
          }
        } catch (error) {
          console.log(`MoonSync: Failed to download cover for "${title}"`, error);
        }
      }
      const content = generateBookTemplate(
        title,
        bookInfo.author || "",
        coverPath,
        this.settings.showDescription ? (_a = bookInfo.description) != null ? _a : null : null,
        (_b = bookInfo.publishedDate) != null ? _b : null,
        (_c = bookInfo.publisher) != null ? _c : null,
        (_d = bookInfo.pageCount) != null ? _d : null,
        (_e = bookInfo.genres) != null ? _e : null,
        (_f = bookInfo.series) != null ? _f : null,
        (_g = bookInfo.language) != null ? _g : null
      );
      await this.app.vault.create(filePath, content);
      progressNotice.hide();
      new import_obsidian7.Notice(`MoonSync: Created note for "${title}"`);
      if (this.settings.showIndex) {
        await refreshIndexNote(this.app, this.settings);
      }
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        await this.app.workspace.openLinkText(filePath, "", true);
      }
    } catch (error) {
      progressNotice.hide();
      console.error("MoonSync: Failed to create book note", error);
      new import_obsidian7.Notice(`MoonSync: Failed to create book note - ${error}`);
    }
  }
  async refreshIndex() {
    await refreshIndexNote(this.app, this.settings);
  }
  async refreshBase() {
    await refreshBaseFile(this.app, this.settings);
  }
  async deleteIndex() {
    const outputPath = (0, import_obsidian7.normalizePath)(this.settings.outputFolder);
    const indexPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${this.settings.indexNoteTitle}.md`);
    if (await this.app.vault.adapter.exists(indexPath)) {
      const file = this.app.vault.getAbstractFileByPath(indexPath);
      if (file) {
        await this.app.vault.delete(file);
        new import_obsidian7.Notice("MoonSync: Index note deleted");
      }
    }
  }
  async deleteBase() {
    const outputPath = (0, import_obsidian7.normalizePath)(this.settings.outputFolder);
    const basePath = (0, import_obsidian7.normalizePath)(`${outputPath}/${this.settings.baseFileName}.base`);
    if (await this.app.vault.adapter.exists(basePath)) {
      const file = this.app.vault.getAbstractFileByPath(basePath);
      if (file) {
        await this.app.vault.delete(file);
        new import_obsidian7.Notice("MoonSync: Base file deleted");
      }
    }
  }
  async renameIndex(oldName, newName) {
    const outputPath = (0, import_obsidian7.normalizePath)(this.settings.outputFolder);
    const oldPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${oldName}.md`);
    const newPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${newName}.md`);
    const file = this.app.vault.getAbstractFileByPath(oldPath);
    if (file) {
      await this.app.fileManager.renameFile(file, newPath);
    }
  }
  async renameBase(oldName, newName) {
    const outputPath = (0, import_obsidian7.normalizePath)(this.settings.outputFolder);
    const oldPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${oldName}.base`);
    const newPath = (0, import_obsidian7.normalizePath)(`${outputPath}/${newName}.base`);
    const file = this.app.vault.getAbstractFileByPath(oldPath);
    if (file) {
      await this.app.fileManager.renameFile(file, newPath);
    }
  }
  /**
   * Import a Moon Reader manual export note
   */
  async importManualExport() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian7.Notice("MoonSync: No active file to import");
      return;
    }
    const progressNotice = new import_obsidian7.Notice("MoonSync: Importing note...", 0);
    try {
      const content = await this.app.vault.read(activeFile);
      const exportData = parseManualExport(content);
      if (!exportData) {
        progressNotice.hide();
        new import_obsidian7.Notice("MoonSync: File is not a valid Moon Reader export");
        return;
      }
      const outputPath = (0, import_obsidian7.normalizePath)(this.settings.outputFolder);
      const filename = generateFilename(exportData.title);
      const filePath = (0, import_obsidian7.normalizePath)(`${outputPath}/${filename}.md`);
      if (await this.app.vault.adapter.exists(filePath)) {
        progressNotice.hide();
        new import_obsidian7.Notice(`MoonSync: A note for "${exportData.title}" already exists`);
        return;
      }
      if (!await this.app.vault.adapter.exists(outputPath)) {
        await this.app.vault.createFolder(outputPath);
      }
      let coverPath = null;
      let description = null;
      let publishedDate = null;
      let publisher = null;
      let pageCount = null;
      let genres = null;
      let series = null;
      let language = null;
      try {
        const bookInfo = await fetchBookInfo(exportData.title, exportData.author);
        if (bookInfo.coverUrl) {
          const coversFolder = (0, import_obsidian7.normalizePath)(`${outputPath}/moonsync-covers`);
          if (!await this.app.vault.adapter.exists(coversFolder)) {
            await this.app.vault.createFolder(coversFolder);
          }
          const coverFilename = `${filename}.jpg`;
          const coverFilePath = (0, import_obsidian7.normalizePath)(`${coversFolder}/${coverFilename}`);
          const imageData = await downloadCover(bookInfo.coverUrl);
          if (imageData) {
            await this.app.vault.adapter.writeBinary(coverFilePath, imageData);
            coverPath = `moonsync-covers/${coverFilename}`;
          }
        }
        description = bookInfo.description;
        publishedDate = bookInfo.publishedDate;
        publisher = bookInfo.publisher;
        pageCount = bookInfo.pageCount;
        genres = bookInfo.genres;
        series = bookInfo.series;
        language = bookInfo.language;
      } catch (error) {
        console.log(`MoonSync: Failed to fetch book info for "${exportData.title}"`, error);
      }
      const bookData = {
        book: {
          id: 0,
          title: exportData.title,
          author: exportData.author,
          filename: "",
          description: "",
          category: "",
          thumbFile: "",
          coverFile: "",
          addTime: "",
          favorite: ""
        },
        highlights: exportData.highlights,
        statistics: null,
        progress: null,
        currentChapter: null,
        lastReadTimestamp: null,
        coverPath,
        fetchedDescription: description,
        publishedDate,
        publisher,
        pageCount,
        genres,
        series,
        isbn10: null,
        isbn13: null,
        language
      };
      const noteContent = generateBookNote(bookData, this.settings);
      await this.app.vault.create(filePath, noteContent);
      progressNotice.hide();
      new import_obsidian7.Notice(`MoonSync: Imported "${exportData.title}" with ${exportData.highlights.length} highlights`);
      if (this.settings.showIndex) {
        await refreshIndexNote(this.app, this.settings);
      }
      if (this.settings.generateBaseFile) {
        await refreshBaseFile(this.app, this.settings);
      }
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        await this.app.workspace.openLinkText(filePath, "", true);
      }
    } catch (error) {
      progressNotice.hide();
      console.error("MoonSync: Failed to import note", error);
      new import_obsidian7.Notice(`MoonSync: Failed to import note - ${error}`);
    }
  }
  /**
   * Re-fetch book cover for the current note
   */
  async refetchBookCover() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian7.Notice("MoonSync: No active file");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const parsed = parseFrontmatter(content);
      if (!parsed.title) {
        new import_obsidian7.Notice("MoonSync: No title found in frontmatter");
        return;
      }
      const title = parsed.title.replace(/\\"/g, '"');
      const author = parsed.author ? parsed.author.replace(/\\"/g, '"') : "";
      new SelectCoverModal(
        this.app,
        title,
        author,
        async (coverUrl) => {
          const progressNotice = new import_obsidian7.Notice("MoonSync: Downloading cover...", 0);
          try {
            const outputPath = (0, import_obsidian7.normalizePath)(this.settings.outputFolder);
            const coversFolder = (0, import_obsidian7.normalizePath)(`${outputPath}/moonsync-covers`);
            if (!await this.app.vault.adapter.exists(coversFolder)) {
              await this.app.vault.createFolder(coversFolder);
            }
            const filename = generateFilename(title);
            const coverFilename = `${filename}.jpg`;
            const coverFilePath = (0, import_obsidian7.normalizePath)(`${coversFolder}/${coverFilename}`);
            const imageData = await downloadAndResizeCover(coverUrl);
            if (!imageData) {
              progressNotice.hide();
              new import_obsidian7.Notice("MoonSync: Failed to download cover image");
              return;
            }
            const existingFile = this.app.vault.getAbstractFileByPath(coverFilePath);
            if (existingFile instanceof import_obsidian7.TFile) {
              await this.app.vault.delete(existingFile);
            }
            await this.app.vault.createBinary(coverFilePath, imageData);
            const coverPath = `moonsync-covers/${coverFilename}`;
            const updatedContent = this.updateNoteCover(content, coverPath);
            const contentWithoutEmbed = updatedContent.replace(/!\[\[moonsync-covers\/[^\]]+\]\]\n?/, "");
            await this.app.vault.modify(activeFile, contentWithoutEmbed);
            await new Promise((resolve) => setTimeout(resolve, 50));
            await this.app.vault.modify(activeFile, updatedContent);
            await refreshIndexNote(this.app, this.settings);
            progressNotice.hide();
            new import_obsidian7.Notice("MoonSync: Cover updated successfully");
          } catch (error) {
            progressNotice.hide();
            console.error("MoonSync: Failed to download cover", error);
            new import_obsidian7.Notice(`MoonSync: Failed to download cover - ${error}`);
          }
        }
      ).open();
    } catch (error) {
      console.error("MoonSync: Failed to re-fetch cover", error);
      new import_obsidian7.Notice(`MoonSync: Failed to re-fetch cover - ${error}`);
    }
  }
  /**
   * Update the cover field in frontmatter and add/update cover embed in note body
   */
  updateNoteCover(content, coverPath) {
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      return content;
    }
    const frontmatter = frontmatterMatch[1];
    let contentAfterFrontmatter = content.slice(frontmatterMatch[0].length);
    const lines = [];
    lines.push("---");
    let coverUpdated = false;
    for (const line of frontmatter.split("\n")) {
      if (line.startsWith("cover:")) {
        lines.push(`cover: "${coverPath}"`);
        coverUpdated = true;
      } else {
        lines.push(line);
      }
    }
    if (!coverUpdated) {
      lines.push(`cover: "${coverPath}"`);
    }
    lines.push("---");
    const coverEmbed = `![[${coverPath}|200]]`;
    const coverEmbedPattern = /!\[\[moonsync-covers\/[^\]]+\|\d+\]\]/;
    if (coverEmbedPattern.test(contentAfterFrontmatter)) {
      contentAfterFrontmatter = contentAfterFrontmatter.replace(coverEmbedPattern, coverEmbed);
    } else {
      const authorPattern = /(\*\*Author:\*\*[^\n]*\n)/;
      const titlePattern = /(# [^\n]+\n)/;
      if (authorPattern.test(contentAfterFrontmatter)) {
        contentAfterFrontmatter = contentAfterFrontmatter.replace(
          authorPattern,
          `$1
${coverEmbed}
`
        );
      } else if (titlePattern.test(contentAfterFrontmatter)) {
        contentAfterFrontmatter = contentAfterFrontmatter.replace(
          titlePattern,
          `$1
${coverEmbed}
`
        );
      }
    }
    return lines.join("\n") + contentAfterFrontmatter;
  }
  /**
   * Fetch and replace all book metadata for the current note
   */
  async fetchBookMetadata() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian7.Notice("MoonSync: No active file");
      return;
    }
    try {
      const content = await this.app.vault.read(activeFile);
      const parsed = parseFrontmatter(content);
      if (!parsed.title) {
        new import_obsidian7.Notice("MoonSync: No title found in frontmatter");
        return;
      }
      const title = parsed.title.replace(/\\"/g, '"');
      const author = parsed.author ? parsed.author.replace(/\\"/g, '"') : "";
      new SelectBookMetadataModal(
        this.app,
        title,
        author,
        async (bookInfo) => {
          var _a;
          const progressNotice = new import_obsidian7.Notice("MoonSync: Updating metadata...", 0);
          try {
            const fileDir = ((_a = activeFile.parent) == null ? void 0 : _a.path) || "";
            const coversFolder = (0, import_obsidian7.normalizePath)(`${fileDir}/moonsync-covers`);
            let coverPath = null;
            const newTitle = bookInfo.title || title;
            const newFilename = generateFilename(newTitle);
            const newFilePath = (0, import_obsidian7.normalizePath)(`${fileDir}/${newFilename}.md`);
            if (bookInfo.coverUrl) {
              if (!await this.app.vault.adapter.exists(coversFolder)) {
                await this.app.vault.createFolder(coversFolder);
              }
              const coverFilename = `${newFilename}.jpg`;
              const coverFilePath = (0, import_obsidian7.normalizePath)(`${coversFolder}/${coverFilename}`);
              const imageData = await downloadAndResizeCover(bookInfo.coverUrl);
              if (imageData) {
                const existingCover = this.app.vault.getAbstractFileByPath(coverFilePath);
                if (existingCover instanceof import_obsidian7.TFile) {
                  await this.app.vault.delete(existingCover);
                }
                await this.app.vault.createBinary(coverFilePath, imageData);
                coverPath = `moonsync-covers/${coverFilename}`;
              }
            }
            const updatedContent = this.updateNoteMetadata(content, bookInfo, coverPath);
            const contentWithoutEmbed = updatedContent.replace(/!\[\[moonsync-covers\/[^\]]+\]\]\n?/, "");
            await this.app.vault.modify(activeFile, contentWithoutEmbed);
            await new Promise((resolve) => setTimeout(resolve, 50));
            await this.app.vault.modify(activeFile, updatedContent);
            if (activeFile.basename !== newFilename) {
              await this.app.fileManager.renameFile(activeFile, newFilePath);
            }
            await refreshIndexNote(this.app, this.settings);
            progressNotice.hide();
            new import_obsidian7.Notice("MoonSync: Metadata updated successfully");
          } catch (error) {
            progressNotice.hide();
            console.error("MoonSync: Failed to update metadata", error);
            new import_obsidian7.Notice(`MoonSync: Failed to update metadata - ${error}`);
          }
        }
      ).open();
    } catch (error) {
      console.error("MoonSync: Failed to fetch metadata", error);
      new import_obsidian7.Notice(`MoonSync: Failed to fetch metadata - ${error}`);
    }
  }
  /**
   * Update all metadata fields in frontmatter and note body
   */
  updateNoteMetadata(content, bookInfo, coverPath) {
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      return content;
    }
    const frontmatter = frontmatterMatch[1];
    let contentAfterFrontmatter = content.slice(frontmatterMatch[0].length);
    const escapeYaml3 = (str) => str.replace(/"/g, '\\"').replace(/\n/g, " ");
    const fieldsToReplace = /* @__PURE__ */ new Set(["title", "author", "published_date", "publisher", "page_count", "genres", "series", "language", "cover", "rating", "ratings_count", "custom_metadata"]);
    const frontmatterLines = [];
    let skipNextLines = false;
    for (const line of frontmatter.split("\n")) {
      if (line.startsWith("  -")) {
        if (skipNextLines)
          continue;
        frontmatterLines.push(line);
        continue;
      }
      skipNextLines = false;
      const fieldMatch = line.match(/^(\w+):/);
      if (fieldMatch) {
        const field = fieldMatch[1];
        if (fieldsToReplace.has(field)) {
          if (field === "genres") {
            skipNextLines = true;
          }
          continue;
        }
      }
      frontmatterLines.push(line);
    }
    const lines = [];
    lines.push("---");
    for (const line of frontmatterLines) {
      if (line.trim()) {
        lines.push(line);
      }
    }
    if (bookInfo.title) {
      lines.push(`title: "${escapeYaml3(bookInfo.title)}"`);
    }
    if (bookInfo.author) {
      lines.push(`author: "${escapeYaml3(bookInfo.author)}"`);
    }
    if (bookInfo.publishedDate) {
      lines.push(`published_date: "${escapeYaml3(bookInfo.publishedDate)}"`);
    }
    if (bookInfo.publisher) {
      lines.push(`publisher: "${escapeYaml3(bookInfo.publisher)}"`);
    }
    if (bookInfo.pageCount !== null) {
      lines.push(`page_count: ${bookInfo.pageCount}`);
    }
    if (bookInfo.genres && bookInfo.genres.length > 0) {
      lines.push(`genres:`);
      for (const genre of bookInfo.genres) {
        lines.push(`  - "${escapeYaml3(genre)}"`);
      }
    }
    if (bookInfo.series) {
      lines.push(`series: "${escapeYaml3(bookInfo.series)}"`);
    }
    if (bookInfo.language) {
      lines.push(`language: "${bookInfo.language}"`);
    }
    if (coverPath) {
      lines.push(`cover: "${coverPath}"`);
    }
    lines.push(`custom_metadata: true`);
    lines.push("---");
    if (bookInfo.title) {
      contentAfterFrontmatter = contentAfterFrontmatter.replace(
        /^(# ).+$/m,
        `$1${bookInfo.title}`
      );
    }
    if (bookInfo.author) {
      if (/\*\*Author:\*\*/.test(contentAfterFrontmatter)) {
        contentAfterFrontmatter = contentAfterFrontmatter.replace(
          /\*\*Author:\*\*[^\n]*/,
          `**Author:** ${bookInfo.author}`
        );
      }
    }
    if (coverPath) {
      const coverEmbed = `![[${coverPath}|200]]`;
      const coverEmbedPattern = /!\[\[moonsync-covers\/[^\]]+\|\d+\]\]/;
      if (coverEmbedPattern.test(contentAfterFrontmatter)) {
        contentAfterFrontmatter = contentAfterFrontmatter.replace(coverEmbedPattern, coverEmbed);
      } else {
        const authorPattern = /(\*\*Author:\*\*[^\n]*\n)/;
        const titlePattern = /(# [^\n]+\n)/;
        if (authorPattern.test(contentAfterFrontmatter)) {
          contentAfterFrontmatter = contentAfterFrontmatter.replace(
            authorPattern,
            `$1
${coverEmbed}
`
          );
        } else if (titlePattern.test(contentAfterFrontmatter)) {
          contentAfterFrontmatter = contentAfterFrontmatter.replace(
            titlePattern,
            `$1
${coverEmbed}
`
          );
        }
      }
    }
    return lines.join("\n") + contentAfterFrontmatter;
  }
};
