/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MoonSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  dropboxPath: "",
  outputFolder: "Books",
  syncOnStartup: true,
  showRibbonIcon: true,
  showDescription: true,
  showReadingProgress: true,
  showHighlightColors: true,
  fetchCovers: true,
  showRatings: false,
  showNotes: true,
  showIndex: true,
  indexNoteTitle: "1. Library Index",
  generateBaseFile: true,
  baseFileName: "2. Books Database",
  showCoverCollage: true,
  coverCollageLimit: 0,
  // 0 = show all
  coverCollageSort: "alpha"
};
function getCalloutType(colorInt) {
  const r = colorInt >> 16 & 255;
  const g = colorInt >> 8 & 255;
  const b = colorInt & 255;
  if (r > 200 && g > 200 && b < 100) {
    return "quote";
  }
  if (b > r && b > g && b > 150) {
    return "info";
  }
  if (g > r && g > b && g > 150) {
    return "tip";
  }
  if (r > g && r > b && r > 150) {
    return "warning";
  }
  if (r > 200 && g > 100 && g < 200 && b < 100) {
    return "warning";
  }
  return "quote";
}
function formatDuration(ms) {
  const totalMinutes = Math.floor(ms / 6e4);
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
}
function formatDate(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric"
  });
}

// src/settings.ts
var import_obsidian = require("obsidian");
var MoonSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "MoonSync Settings" });
    containerEl.createEl("h3", { text: "About" });
    new import_obsidian.Setting(containerEl).setName("Sync your Moon Reader highlights to Obsidian").setDesc("Book covers, descriptions, and ratings from Google Books/Open Library").addButton(
      (button) => button.setButtonText("GitHub").onClick(() => {
        window.open("https://github.com/titandrive/moonsync");
      })
    );
    const configHeader = containerEl.createEl("h2", { text: "Configuration" });
    configHeader.createSpan({ text: "\xA0\xA0\xA0\xA0\xA0\xA0" });
    configHeader.createSpan({ text: "Set up MoonSync.", cls: "setting-item-description" });
    let textComponent;
    new import_obsidian.Setting(containerEl).setName("Moon Reader Dropbox Path").setDesc(
      "Path to your Books folder in Dropbox (usually Dropbox/Apps/Books). The plugin will find the hidden .Moon+ folder automatically."
    ).addText((text) => {
      textComponent = text;
      text.setPlaceholder("/Users/you/Dropbox/Apps/Books").setValue(this.plugin.settings.dropboxPath).onChange(async (value) => {
        this.plugin.settings.dropboxPath = value;
        await this.plugin.saveSettings();
      });
    }).addButton(
      (button) => button.setButtonText("Browse").onClick(async () => {
        const folder = await this.openFolderPicker();
        if (folder) {
          this.plugin.settings.dropboxPath = folder;
          textComponent.setValue(folder);
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Output Folder").setDesc("Folder in your vault where book notes will be created").addText(
      (text) => text.setPlaceholder("Books").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
        this.plugin.settings.outputFolder = value || "Books";
        await this.plugin.saveSettings();
      })
    );
    const syncHeader = containerEl.createEl("h2", { text: "Sync" });
    syncHeader.createSpan({ text: "\xA0\xA0\xA0\xA0\xA0\xA0" });
    syncHeader.createSpan({ text: "Control how MoonSync works.", cls: "setting-item-description" });
    new import_obsidian.Setting(containerEl).setName("Sync Now").setDesc("Manually trigger a sync from Moon Reader").addButton(
      (button) => button.setButtonText("Sync").onClick(async () => {
        await this.plugin.runSync();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync on Startup").setDesc("Automatically sync when Obsidian starts").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.syncOnStartup).onChange(async (value) => {
        this.plugin.settings.syncOnStartup = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Ribbon Icon").setDesc("Show sync button in ribbon menu").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showRibbonIcon).onChange(async (value) => {
        this.plugin.settings.showRibbonIcon = value;
        await this.plugin.saveSettings();
        this.plugin.updateRibbonIcon();
      })
    );
    const noteHeader = containerEl.createEl("h2", { text: "Note Content" });
    noteHeader.createSpan({ text: "\xA0\xA0\xA0\xA0\xA0\xA0" });
    noteHeader.createSpan({ text: "Control what data is included in book notes.", cls: "setting-item-description" });
    new import_obsidian.Setting(containerEl).setName("Show Description").setDesc("Include book description in generated notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showDescription).onChange(async (value) => {
        this.plugin.settings.showDescription = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Ratings").setDesc("Include Google Books rating in generated notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showRatings).onChange(async (value) => {
        this.plugin.settings.showRatings = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Reading Progress").setDesc("Include reading progress section. Note: Progress data may not always be accurate depending on Moon Reader sync.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showReadingProgress).onChange(async (value) => {
        this.plugin.settings.showReadingProgress = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Highlight Colors").setDesc("Use different callout styles based on highlight color. When off, all highlights appear as quotes.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showHighlightColors).onChange(async (value) => {
        this.plugin.settings.showHighlightColors = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Fetch Book Covers").setDesc("Download book covers from Open Library/Google Books. Covers are saved in a 'covers' subfolder.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.fetchCovers).onChange(async (value) => {
        this.plugin.settings.fetchCovers = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Notes").setDesc("Include your personal notes/annotations below highlights").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showNotes).onChange(async (value) => {
        this.plugin.settings.showNotes = value;
        await this.plugin.saveSettings();
      })
    );
    const indexHeader = containerEl.createEl("h2", { text: "Index" });
    indexHeader.createSpan({ text: "\xA0\xA0\xA0\xA0\xA0\xA0" });
    indexHeader.createSpan({ text: "Control what is shown on the book index page.", cls: "setting-item-description" });
    new import_obsidian.Setting(containerEl).setName("Generate Library Index").setDesc("Create an index note with summary stats and links to all books").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showIndex).onChange(async (value) => {
        this.plugin.settings.showIndex = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Index Note Title").setDesc("Name of the library index note").addText(
      (text) => text.setPlaceholder("1. Library Index").setValue(this.plugin.settings.indexNoteTitle).onChange(async (value) => {
        this.plugin.settings.indexNoteTitle = value || "1. Library Index";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Cover Collage").setDesc("Display book covers at the top of the library index").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showCoverCollage).onChange(async (value) => {
        this.plugin.settings.showCoverCollage = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Cover Collage Limit").setDesc("Maximum number of covers to show (0 = show all)").addText(
      (text) => text.setPlaceholder("0").setValue(String(this.plugin.settings.coverCollageLimit)).onChange(async (value) => {
        const num = parseInt(value) || 0;
        this.plugin.settings.coverCollageLimit = Math.max(0, num);
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Cover Collage Sort").setDesc("How to sort covers in the collage").addDropdown(
      (dropdown) => dropdown.addOption("alpha", "Alphabetical").addOption("recent", "Most Recent").setValue(this.plugin.settings.coverCollageSort).onChange(async (value) => {
        this.plugin.settings.coverCollageSort = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshIndex();
      })
    );
    const basesHeader = containerEl.createEl("h2", { text: "Obsidian Bases" });
    basesHeader.createSpan({ text: "\xA0\xA0\xA0\xA0\xA0\xA0" });
    basesHeader.createSpan({ text: "Auto-generate database view configuration for the Bases plugin.", cls: "setting-item-description" });
    new import_obsidian.Setting(containerEl).setName("Generate Base File").setDesc("Automatically create and update the .base file for the Obsidian Bases plugin").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.generateBaseFile).onChange(async (value) => {
        this.plugin.settings.generateBaseFile = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.refreshBase();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Base File Name").setDesc("Name of the .base file (without extension)").addText(
      (text) => text.setPlaceholder("2. Books Database").setValue(this.plugin.settings.baseFileName).onChange(async (value) => {
        this.plugin.settings.baseFileName = value || "2. Books Database";
        await this.plugin.saveSettings();
        if (this.plugin.settings.generateBaseFile) {
          await this.plugin.refreshBase();
        }
      })
    );
    containerEl.createEl("h2", { text: "Support" });
    new import_obsidian.Setting(containerEl).setName("Buy me a coffee").setDesc("If you find this plugin useful, consider supporting its development!").addButton(
      (button) => button.setButtonText("Ko-fi").onClick(() => {
        window.open("https://ko-fi.com/titandrive");
      })
    );
  }
  async openFolderPicker() {
    const { exec } = require("child_process");
    const { platform } = require("os");
    return new Promise((resolve) => {
      if (platform() === "darwin") {
        const script = `osascript -e 'POSIX path of (choose folder with prompt "Select Moon Reader Dropbox folder")'`;
        exec(script, (error, stdout) => {
          if (error) {
            resolve(null);
          } else {
            resolve(stdout.trim());
          }
        });
      } else if (platform() === "win32") {
        const script = `powershell -command "Add-Type -AssemblyName System.Windows.Forms; $f = New-Object System.Windows.Forms.FolderBrowserDialog; $f.ShowDialog() | Out-Null; $f.SelectedPath"`;
        exec(script, (error, stdout) => {
          if (error) {
            resolve(null);
          } else {
            resolve(stdout.trim());
          }
        });
      } else {
        exec(
          'zenity --file-selection --directory --title="Select Moon Reader folder"',
          (error, stdout) => {
            if (error) {
              resolve(null);
            } else {
              resolve(stdout.trim());
            }
          }
        );
      }
    });
  }
};

// src/sync.ts
var import_obsidian6 = require("obsidian");

// src/modal.ts
var import_obsidian2 = require("obsidian");
var SyncSummaryModal = class extends import_obsidian2.Modal {
  constructor(app, result) {
    super(app);
    this.result = result;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-summary-modal");
    contentEl.createEl("h2", { text: "MoonSync Import Complete" });
    const statsContainer = contentEl.createDiv({ cls: "moonsync-stats" });
    this.createStatItem(statsContainer, this.result.booksCreated.toString(), "Books Imported");
    this.createStatItem(statsContainer, this.result.booksCreated.toString(), "Notes Created");
    this.createStatItem(statsContainer, this.result.totalHighlights.toString(), "Highlights");
    this.createStatItem(statsContainer, this.result.totalNotes.toString(), "Notes");
    const settingsLink = contentEl.createDiv({ cls: "moonsync-settings-link" });
    const link = settingsLink.createEl("a", { text: "Open MoonSync Settings" });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.close();
      this.app.setting.open();
      this.app.setting.openTabById("moonsync");
    });
    const buttonContainer = contentEl.createDiv({ cls: "moonsync-button-container" });
    const closeButton = buttonContainer.createEl("button", { text: "Done" });
    closeButton.addEventListener("click", () => this.close());
  }
  createStatItem(container, value, label) {
    const item = container.createDiv({ cls: "moonsync-stat-item" });
    item.createDiv({ cls: "moonsync-stat-value", text: value });
    item.createDiv({ cls: "moonsync-stat-label", text: label });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CreateBookModal = class extends import_obsidian2.Modal {
  constructor(app, settings, onSubmit) {
    super(app);
    this.title = "";
    this.author = "";
    this.settings = settings;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("moonsync-create-book-modal");
    contentEl.createEl("h2", { text: "Create Book Note" });
    new import_obsidian2.Setting(contentEl).setName("Title").setDesc("Book title (required)").addText(
      (text) => text.setPlaceholder("Enter book title").onChange((value) => {
        this.title = value;
      })
    );
    new import_obsidian2.Setting(contentEl).setName("Author").setDesc("Author name (optional)").addText(
      (text) => text.setPlaceholder("Enter author name").onChange((value) => {
        this.author = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "moonsync-button-container" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => {
      if (!this.title.trim()) {
        new import_obsidian2.Notice("Please enter a book title");
        return;
      }
      this.onSubmit(this.title.trim(), this.author.trim());
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function generateBookTemplate(title, author, coverPath, description, rating, ratingsCount, publishedDate = null, publisher = null, pageCount = null, genres = null, series = null, language = null) {
  const lines = [];
  const escapeYaml3 = (str) => str.replace(/"/g, '\\"').replace(/\n/g, " ");
  lines.push("---");
  lines.push(`title: "${escapeYaml3(title)}"`);
  if (author) {
    lines.push(`author: "${escapeYaml3(author)}"`);
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push("highlights_count: 0");
  lines.push("manual_note: true");
  if (rating !== null) {
    lines.push(`rating: ${rating}`);
    if (ratingsCount !== null) {
      lines.push(`ratings_count: ${ratingsCount}`);
    }
  }
  if (publishedDate) {
    lines.push(`published_date: "${escapeYaml3(publishedDate)}"`);
  }
  if (publisher) {
    lines.push(`publisher: "${escapeYaml3(publisher)}"`);
  }
  if (pageCount !== null) {
    lines.push(`page_count: ${pageCount}`);
  }
  if (genres && genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of genres) {
      lines.push(`  - "${escapeYaml3(genre)}"`);
    }
  }
  if (series) {
    lines.push(`series: "${escapeYaml3(series)}"`);
  }
  if (language) {
    lines.push(`language: "${language}"`);
  }
  if (coverPath) {
    lines.push(`cover: "${coverPath}"`);
  }
  lines.push("---");
  lines.push(`# ${title}`);
  if (author) {
    lines.push(`**Author:** ${author}`);
  }
  if (rating !== null) {
    const ratingText = ratingsCount !== null ? `**Rating:** \u2B50 ${rating}/5 (${ratingsCount.toLocaleString()} ratings)` : `**Rating:** \u2B50 ${rating}/5`;
    lines.push(ratingText);
  }
  lines.push("");
  if (coverPath) {
    lines.push(`![[${coverPath}|200]]`);
    lines.push("");
  }
  if (description) {
    lines.push("## Description");
    lines.push(description);
    lines.push("");
  }
  lines.push("## Highlights");
  lines.push("");
  lines.push("> [!quote]");
  lines.push("> Add your highlights here...");
  lines.push("");
  return lines.join("\n");
}

// src/parser/annotations.ts
var import_promises = require("fs/promises");
var import_path = require("path");
var import_zlib = require("zlib");
function normalizeBookTitle(title, author) {
  let normalized = title.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)$/i, "");
  if (author && normalized.endsWith(` - ${author}`)) {
    normalized = normalized.slice(0, -` - ${author}`.length);
  }
  return normalized.trim();
}
function parseAnnotationFile(data, filename) {
  try {
    const decompressed = (0, import_zlib.inflateSync)(data).toString("utf-8");
    const lines = decompressed.split("\n");
    const baseName = filename.replace(/\.epub\.an$/, "").replace(/\.pdf\.an$/, "");
    const parts = baseName.split(" - ");
    const bookTitle = normalizeBookTitle(parts[0] || baseName);
    const author = parts.length > 1 ? parts.slice(1).join(" - ") : "";
    const highlights = [];
    let i = 0;
    while (i < lines.length && lines[i] !== "#") {
      i++;
    }
    while (i < lines.length) {
      if (lines[i] === "#") {
        i++;
        if (i >= lines.length)
          break;
        const id = parseInt(lines[i++] || "0", 10);
        const title = lines[i++] || "";
        const fullPath = lines[i++] || "";
        const lowerPath = lines[i++] || "";
        const chapter = parseInt(lines[i++] || "0", 10);
        i++;
        const position = parseInt(lines[i++] || "0", 10);
        const length = parseInt(lines[i++] || "0", 10);
        const color = parseInt(lines[i++] || "0", 10);
        const timestamp = parseInt(lines[i++] || "0", 10);
        while (i < lines.length && lines[i] === "") {
          i++;
        }
        let text = "";
        let note = "";
        if (i < lines.length && lines[i] !== "0") {
          const firstLine = lines[i].replace(/<BR>/g, "\n").trim();
          i++;
          if (i < lines.length && lines[i] !== "0" && lines[i] !== "") {
            note = firstLine;
            text = lines[i].replace(/<BR>/g, "\n").trim();
            i++;
          } else {
            text = firstLine;
          }
        }
        while (i < lines.length && (lines[i] === "0" || lines[i] === "")) {
          i++;
        }
        if (text) {
          highlights.push({
            id,
            book: normalizeBookTitle(title, author),
            filename: fullPath,
            chapter,
            position,
            highlightLength: length,
            highlightColor: color,
            timestamp,
            bookmark: "",
            note,
            originalText: text,
            underline: false,
            strikethrough: false
          });
        }
      } else {
        i++;
      }
    }
    return {
      filename,
      bookTitle,
      author,
      highlights
    };
  } catch (error) {
    console.log(`MoonSync: Failed to parse annotation file ${filename}`, error);
    return null;
  }
}
function parseProgressFile(data) {
  try {
    const content = data.toString("utf-8").trim();
    const match = content.match(/^(\d+)\*(\d+)@\d+#\d+:(\d+(?:\.\d+)?)%$/);
    if (match) {
      return {
        timestamp: parseInt(match[1], 10),
        chapter: parseInt(match[2], 10),
        progress: parseFloat(match[3])
      };
    }
  } catch (e) {
  }
  return null;
}
async function parseAnnotationFiles(dropboxPath) {
  var _a, _b;
  const cacheDir = (0, import_path.join)(dropboxPath, ".Moon+", "Cache");
  const bookDataMap = /* @__PURE__ */ new Map();
  try {
    const files = await (0, import_promises.readdir)(cacheDir);
    const anFiles = files.filter((f) => f.endsWith(".an"));
    for (const anFile of anFiles) {
      try {
        const filePath = (0, import_path.join)(cacheDir, anFile);
        const data = await (0, import_promises.readFile)(filePath);
        const parsed = parseAnnotationFile(data, anFile);
        if (parsed && parsed.highlights.length > 0) {
          const actualTitle = ((_a = parsed.highlights[0]) == null ? void 0 : _a.book) || parsed.bookTitle;
          const key = actualTitle.toLowerCase();
          if (!bookDataMap.has(key)) {
            const book = {
              id: 0,
              title: actualTitle,
              filename: ((_b = parsed.highlights[0]) == null ? void 0 : _b.filename) || "",
              author: parsed.author,
              description: "",
              category: "",
              thumbFile: "",
              coverFile: "",
              addTime: "",
              favorite: ""
            };
            bookDataMap.set(key, {
              book,
              highlights: [],
              statistics: null,
              progress: null,
              currentChapter: null,
              lastReadTimestamp: null,
              coverPath: null,
              fetchedDescription: null,
              rating: null,
              ratingsCount: null,
              publishedDate: null,
              publisher: null,
              pageCount: null,
              genres: null,
              series: null,
              isbn10: null,
              isbn13: null,
              language: null
            });
          }
          const bookData = bookDataMap.get(key);
          bookData.highlights.push(...parsed.highlights);
        }
      } catch (error) {
        console.log(`MoonSync: Error reading ${anFile}`, error);
      }
    }
    const poFiles = files.filter((f) => f.endsWith(".po"));
    for (const poFile of poFiles) {
      try {
        const baseName = poFile.replace(/\.epub\.po$/, "").replace(/\.pdf\.po$/, "");
        const parts = baseName.split(" - ");
        let bookTitle = parts[0] || baseName;
        if (!bookTitle.includes(" ") && bookTitle.includes("_")) {
          bookTitle = bookTitle.replace(/_/g, " ");
        }
        const key = bookTitle.toLowerCase();
        if (bookDataMap.has(key)) {
          const filePath = (0, import_path.join)(cacheDir, poFile);
          const data = await (0, import_promises.readFile)(filePath);
          const progressData = parseProgressFile(data);
          if (progressData !== null) {
            const bookData = bookDataMap.get(key);
            bookData.progress = progressData.progress;
            bookData.currentChapter = progressData.chapter;
            bookData.lastReadTimestamp = progressData.timestamp;
          }
        }
      } catch (error) {
        console.log(`MoonSync: Error reading ${poFile}`, error);
      }
    }
    for (const bookData of bookDataMap.values()) {
      bookData.highlights.sort((a, b) => a.position - b.position);
    }
    return Array.from(bookDataMap.values());
  } catch (error) {
    console.log("MoonSync: Failed to read Cache directory", error);
    return [];
  }
}

// src/writer/markdown.ts
function generateBookNote(bookData, settings) {
  const { book, highlights, statistics, progress, currentChapter, lastReadTimestamp, coverPath, fetchedDescription, publishedDate, publisher, pageCount, genres, series, isbn10, isbn13, language } = bookData;
  const lines = [];
  lines.push("---");
  lines.push(`title: "${escapeYaml(book.title)}"`);
  if (book.author) {
    lines.push(`author: "${escapeYaml(book.author)}"`);
  }
  if (book.category) {
    const category = parseCategory(book.category);
    if (category) {
      lines.push(`category: "${escapeYaml(category)}"`);
    }
  }
  if (progress !== null) {
    lines.push(`progress: ${progress.toFixed(1)}%`);
  }
  if (currentChapter !== null) {
    lines.push(`current_chapter: ${currentChapter}`);
  }
  if (statistics == null ? void 0 : statistics.usedTime) {
    lines.push(`reading_time: "${formatDuration(statistics.usedTime)}"`);
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push(`moon_reader_path: "${escapeYaml(book.filename)}"`);
  lines.push(`highlights_count: ${highlights.length}`);
  const notesCount = highlights.filter((h) => h.note && h.note.trim()).length;
  lines.push(`notes_count: ${notesCount}`);
  if (publishedDate) {
    lines.push(`published_date: "${escapeYaml(publishedDate)}"`);
  }
  if (publisher) {
    lines.push(`publisher: "${escapeYaml(publisher)}"`);
  }
  if (pageCount !== null) {
    lines.push(`page_count: ${pageCount}`);
  }
  if (genres && genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of genres) {
      lines.push(`  - "${escapeYaml(genre)}"`);
    }
  }
  if (series) {
    lines.push(`series: "${escapeYaml(series)}"`);
  }
  if (isbn10) {
    lines.push(`isbn_10: "${isbn10}"`);
  }
  if (isbn13) {
    lines.push(`isbn_13: "${isbn13}"`);
  }
  if (language) {
    lines.push(`language: "${language}"`);
  }
  if (coverPath) {
    lines.push(`cover: "${coverPath}"`);
  }
  lines.push("---");
  lines.push(`# ${book.title}`);
  if (book.author) {
    lines.push(`**Author:** ${book.author}`);
  }
  lines.push("");
  if (coverPath) {
    lines.push(`![[${coverPath}|200]]`);
    lines.push("");
  }
  if (settings.showReadingProgress && (progress !== null || currentChapter !== null)) {
    lines.push("## Reading Progress");
    if (progress !== null) {
      lines.push(`- **Progress:** ${progress.toFixed(1)}%`);
    }
    if (currentChapter !== null) {
      lines.push(`- **Chapter:** ${currentChapter}`);
    }
    lines.push("");
  }
  const description = fetchedDescription || book.description;
  if (settings.showDescription && description && description.trim().length > 0) {
    lines.push("## Description");
    lines.push(description.trim());
    lines.push("");
  }
  if (highlights.length > 0) {
    lines.push("## Highlights");
    lines.push("");
    for (const highlight of highlights) {
      lines.push(formatHighlight(highlight, settings.showHighlightColors, settings.showNotes));
      lines.push("");
    }
  }
  return lines.join("\n");
}
function formatHighlight(highlight, useColors, showNotes) {
  const calloutType = useColors ? getCalloutType(highlight.highlightColor) : "quote";
  const dateStr = highlight.timestamp ? formatDate(highlight.timestamp) : "";
  const chapterStr = highlight.chapter > 0 ? `Chapter ${highlight.chapter}` : "";
  const headerParts = [chapterStr, dateStr].filter((p) => p);
  const header = headerParts.length > 0 ? headerParts.join(" \u2022 ") : "";
  const lines = [];
  if (header) {
    lines.push(`> [!${calloutType}] ${header}`);
  } else {
    lines.push(`> [!${calloutType}]`);
  }
  if (highlight.originalText) {
    const text = highlight.originalText.trim();
    const textLines = text.split("\n");
    for (const line of textLines) {
      lines.push(`> ${line}`);
    }
  }
  if (showNotes && highlight.note && highlight.note.trim()) {
    lines.push(">");
    lines.push(`> ---`);
    lines.push(`> **Note:** ${highlight.note.trim()}`);
  }
  return lines.join("\n");
}
function parseCategory(categoryField) {
  const lines = categoryField.split("\n").map((l) => l.trim()).filter((l) => l && !l.startsWith("<") && !l.startsWith("#"));
  return lines[0] || "";
}
function escapeYaml(str) {
  return str.replace(/"/g, '\\"').replace(/\n/g, " ");
}
function generateFilename(title) {
  return title.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim().substring(0, 100);
}
function generateIndexNote(books, settings) {
  const lines = [];
  lines.push(`# ${settings.indexNoteTitle}`);
  lines.push("");
  if (settings.showCoverCollage) {
    const booksWithCovers = books.filter((b) => b.coverPath);
    if (booksWithCovers.length > 0) {
      let sortedCovers;
      if (settings.coverCollageSort === "recent") {
        sortedCovers = [...booksWithCovers].sort((a, b) => {
          const aTime = a.lastReadTimestamp || 0;
          const bTime = b.lastReadTimestamp || 0;
          if (bTime !== aTime)
            return bTime - aTime;
          return a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase());
        });
      } else {
        sortedCovers = [...booksWithCovers].sort(
          (a, b) => a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase())
        );
      }
      const coversToShow = settings.coverCollageLimit > 0 ? sortedCovers.slice(0, settings.coverCollageLimit) : sortedCovers;
      const coverImgs = coversToShow.map((book) => {
        const noteFilename = generateFilename(book.book.title);
        return `<a class="internal-link" href="${noteFilename}"><img src="${book.coverPath}" height="120"></a>`;
      }).join(" ");
      lines.push(coverImgs);
      lines.push("");
    }
  }
  const totalBooks = books.length;
  const totalHighlights = books.reduce((sum, b) => sum + b.highlights.length, 0);
  const totalNotes = books.reduce(
    (sum, b) => sum + b.highlights.filter((h) => h.note && h.note.trim()).length,
    0
  );
  const booksWithProgress = books.filter((b) => b.progress !== null);
  const avgProgress = booksWithProgress.length > 0 ? booksWithProgress.reduce((sum, b) => sum + (b.progress || 0), 0) / booksWithProgress.length : 0;
  lines.push("## Summary");
  lines.push(`- **Books:** ${totalBooks}`);
  lines.push(`- **Highlights:** ${totalHighlights}`);
  lines.push(`- **Notes:** ${totalNotes}`);
  if (booksWithProgress.length > 0) {
    lines.push(`- **Average Progress:** ${avgProgress.toFixed(1)}%`);
  }
  lines.push("");
  lines.push("## Books");
  const sortedBooks = [...books].sort(
    (a, b) => a.book.title.toLowerCase().localeCompare(b.book.title.toLowerCase())
  );
  for (const bookData of sortedBooks) {
    const filename = generateFilename(bookData.book.title);
    const author = bookData.book.author ? ` by ${bookData.book.author}` : "";
    const progress = bookData.progress !== null ? ` (${bookData.progress.toFixed(0)}%)` : "";
    const highlightCount = bookData.highlights.length;
    const noteCount = bookData.highlights.filter((h) => h.note && h.note.trim()).length;
    const statsText = noteCount > 0 ? `${highlightCount} highlights, ${noteCount} ${noteCount === 1 ? "note" : "notes"}` : `${highlightCount} highlights`;
    lines.push(`- [[${filename}|${bookData.book.title}]]${author}${progress} \u2014 ${statsText}`);
  }
  lines.push("");
  return lines.join("\n");
}
function generateBaseFile(settings) {
  const outputFolder = settings.outputFolder;
  const indexTitle = settings.indexNoteTitle;
  const baseTitle = settings.baseFileName;
  const lines = [];
  lines.push("filters:");
  lines.push("  and:");
  lines.push(`    - file.folder == "${outputFolder}"`);
  lines.push(`    - file.name != "${indexTitle}"`);
  lines.push(`    - file.name != "${baseTitle}"`);
  lines.push('    - file.ext == "md"');
  lines.push("properties:");
  lines.push("  file.name:");
  lines.push("    displayName: Title");
  lines.push("  author:");
  lines.push("    displayName: Author");
  lines.push("  genres:");
  lines.push("    displayName: Genres");
  lines.push("  published_date:");
  lines.push("    displayName: Published");
  lines.push("  page_count:");
  lines.push("    displayName: Pages");
  lines.push("  highlights_count:");
  lines.push("    displayName: Highlights");
  lines.push("  notes_count:");
  lines.push("    displayName: Notes");
  lines.push("  last_synced:");
  lines.push("    displayName: Last Synced");
  lines.push("  publisher:");
  lines.push("    displayName: Publisher");
  lines.push("  series:");
  lines.push("    displayName: Series");
  lines.push("  language:");
  lines.push("    displayName: Language");
  lines.push("  progress:");
  lines.push("    displayName: Progress %");
  lines.push("  manual_note:");
  lines.push("    displayName: Manual");
  lines.push("views:");
  lines.push("  - type: table");
  lines.push("    name: Library");
  lines.push("    order:");
  lines.push("      - file.name");
  lines.push("      - author");
  lines.push("      - highlights_count");
  lines.push("      - progress");
  lines.push("      - notes_count");
  lines.push("      - manual_note");
  lines.push("      - last_synced");
  lines.push("      - genres");
  lines.push("      - page_count");
  lines.push("      - publisher");
  lines.push("      - published_date");
  lines.push("      - language");
  lines.push("    limit: 100");
  lines.push("    properties:");
  lines.push("      - file.name");
  lines.push("      - note.author");
  lines.push("      - note.genres");
  lines.push("      - note.highlights_count");
  lines.push("      - note.notes_count");
  lines.push("      - note.progress");
  lines.push("      - note.manual_note");
  lines.push("      - note.published_date");
  lines.push("      - note.publisher");
  lines.push("      - note.page_count");
  lines.push("      - note.series");
  lines.push("      - note.language");
  lines.push("      - note.last_synced");
  lines.push("  - type: cards");
  lines.push("    name: Gallery");
  lines.push("    order:");
  lines.push("      - file.name");
  lines.push("    limit: 100");
  lines.push("    image: note.cover");
  lines.push("    imageFit: contain");
  lines.push("    cardSize: medium");
  lines.push("    properties:");
  lines.push("      - file.name");
  lines.push("      - note.author");
  lines.push("      - note.published_date");
  return lines.join("\n");
}

// src/covers.ts
var import_obsidian3 = require("obsidian");
async function fetchBookInfo(title, author) {
  const [openLibraryResult, googleBooksResult] = await Promise.all([
    fetchFromOpenLibrary(title, author),
    fetchFromGoogleBooks(title, author)
  ]);
  const coverUrl = openLibraryResult.coverUrl || googleBooksResult.coverUrl;
  const description = googleBooksResult.description || openLibraryResult.description;
  const fetchedTitle = googleBooksResult.title || openLibraryResult.title;
  const fetchedAuthor = googleBooksResult.author || openLibraryResult.author;
  const publishedDate = googleBooksResult.publishedDate || openLibraryResult.publishedDate;
  const publisher = googleBooksResult.publisher || openLibraryResult.publisher;
  const pageCount = googleBooksResult.pageCount || openLibraryResult.pageCount;
  const language = googleBooksResult.language || openLibraryResult.language;
  const genres = [];
  if (googleBooksResult.genres) {
    genres.push(...googleBooksResult.genres);
  }
  if (openLibraryResult.genres) {
    for (const genre of openLibraryResult.genres) {
      if (!genres.some((g) => g.toLowerCase() === genre.toLowerCase())) {
        genres.push(genre);
      }
    }
  }
  const series = openLibraryResult.series;
  let source = null;
  if (coverUrl || description) {
    source = googleBooksResult.description ? "googlebooks" : "openlibrary";
  }
  return {
    title: fetchedTitle,
    coverUrl,
    description,
    author: fetchedAuthor,
    source,
    publishedDate,
    publisher,
    pageCount,
    genres: genres.length > 0 ? genres : null,
    series,
    language
  };
}
async function fetchFromOpenLibrary(title, author) {
  const result = {
    title: null,
    coverUrl: null,
    description: null,
    author: null,
    publishedDate: null,
    publisher: null,
    pageCount: null,
    genres: null,
    series: null,
    language: null
  };
  try {
    const query = encodeURIComponent(`${title} ${author}`);
    const searchUrl = `https://openlibrary.org/search.json?q=${query}&limit=1`;
    const response = await (0, import_obsidian3.requestUrl)({ url: searchUrl });
    const data = response.json;
    if (data.docs && data.docs.length > 0) {
      const book = data.docs[0];
      if (book.title) {
        result.title = book.title;
      }
      if (book.cover_i) {
        result.coverUrl = `https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg`;
      } else if (book.isbn && book.isbn.length > 0) {
        result.coverUrl = `https://covers.openlibrary.org/b/isbn/${book.isbn[0]}-L.jpg`;
      }
      if (book.author_name && book.author_name.length > 0) {
        result.author = book.author_name[0];
      }
      if (book.first_publish_year) {
        result.publishedDate = book.first_publish_year.toString();
      }
      if (book.publisher && book.publisher.length > 0) {
        result.publisher = book.publisher[0];
      }
      if (book.number_of_pages_median) {
        result.pageCount = book.number_of_pages_median;
      }
      if (book.subject && book.subject.length > 0) {
        result.genres = book.subject.slice(0, 5);
      }
      if (book.language && book.language.length > 0) {
        result.language = book.language[0];
      }
      if (book.key) {
        try {
          const workUrl = `https://openlibrary.org${book.key}.json`;
          const workResponse = await (0, import_obsidian3.requestUrl)({ url: workUrl });
          const workData = workResponse.json;
          if (workData.description) {
            result.description = typeof workData.description === "string" ? workData.description : workData.description.value || null;
          }
          if (workData.series && workData.series.length > 0) {
            result.series = workData.series[0];
          }
        } catch (e) {
        }
      }
    }
  } catch (error) {
    console.log("MoonSync: Open Library search failed", error);
  }
  return result;
}
async function fetchFromGoogleBooks(title, author) {
  var _a;
  const result = {
    title: null,
    coverUrl: null,
    description: null,
    author: null,
    publishedDate: null,
    publisher: null,
    pageCount: null,
    genres: null,
    language: null
  };
  try {
    const query = encodeURIComponent(`intitle:${title} inauthor:${author}`);
    const searchUrl = `https://www.googleapis.com/books/v1/volumes?q=${query}&maxResults=1`;
    const response = await (0, import_obsidian3.requestUrl)({ url: searchUrl });
    const data = response.json;
    if (data.items && data.items.length > 0) {
      const book = data.items[0];
      const volumeInfo = book.volumeInfo;
      if (volumeInfo == null ? void 0 : volumeInfo.title) {
        result.title = volumeInfo.title;
      }
      const imageLinks = volumeInfo == null ? void 0 : volumeInfo.imageLinks;
      if (imageLinks) {
        result.coverUrl = (_a = imageLinks.large || imageLinks.medium || imageLinks.thumbnail || imageLinks.smallThumbnail) == null ? void 0 : _a.replace("http://", "https://");
      }
      if (volumeInfo == null ? void 0 : volumeInfo.description) {
        result.description = volumeInfo.description;
      }
      if ((volumeInfo == null ? void 0 : volumeInfo.authors) && volumeInfo.authors.length > 0) {
        result.author = volumeInfo.authors[0];
      }
      if (volumeInfo == null ? void 0 : volumeInfo.publishedDate) {
        result.publishedDate = volumeInfo.publishedDate;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.publisher) {
        result.publisher = volumeInfo.publisher;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.pageCount) {
        result.pageCount = volumeInfo.pageCount;
      }
      if ((volumeInfo == null ? void 0 : volumeInfo.categories) && volumeInfo.categories.length > 0) {
        result.genres = volumeInfo.categories;
      }
      if (volumeInfo == null ? void 0 : volumeInfo.language) {
        result.language = volumeInfo.language;
      }
    }
  } catch (error) {
    console.log("MoonSync: Google Books search failed", error);
  }
  return result;
}
async function downloadCover(url) {
  try {
    const response = await (0, import_obsidian3.requestUrl)({ url });
    return response.arrayBuffer;
  } catch (error) {
    console.log("MoonSync: Failed to download cover", error);
    return null;
  }
}

// src/cache.ts
var import_obsidian4 = require("obsidian");
var CACHE_FILE = ".moonsync-cache.json";
function getCacheKey(title, author) {
  return `${title.toLowerCase()}|${author.toLowerCase()}`;
}
async function loadCache(app, outputFolder) {
  const cachePath = (0, import_obsidian4.normalizePath)(`${outputFolder}/${CACHE_FILE}`);
  try {
    if (await app.vault.adapter.exists(cachePath)) {
      const data = await app.vault.adapter.read(cachePath);
      return JSON.parse(data);
    }
  } catch (error) {
    console.log("MoonSync: Failed to load cache, starting fresh", error);
  }
  return {};
}
async function saveCache(app, outputFolder, cache) {
  const cachePath = (0, import_obsidian4.normalizePath)(`${outputFolder}/${CACHE_FILE}`);
  try {
    await app.vault.adapter.write(cachePath, JSON.stringify(cache, null, 2));
  } catch (error) {
    console.log("MoonSync: Failed to save cache", error);
  }
}
function getCachedInfo(cache, title, author) {
  const key = getCacheKey(title, author);
  return cache[key] || null;
}
function setCachedInfo(cache, title, author, info) {
  const key = getCacheKey(title, author);
  cache[key] = {
    ...info,
    fetchedAt: Date.now()
  };
}

// src/scanner.ts
var import_obsidian5 = require("obsidian");
async function scanAllBookNotes(app, outputPath) {
  const books = [];
  const normalizedPath = (0, import_obsidian5.normalizePath)(outputPath);
  if (!await app.vault.adapter.exists(normalizedPath)) {
    return books;
  }
  const listing = await app.vault.adapter.list(normalizedPath);
  for (const filePath of listing.files) {
    if (!filePath.endsWith(".md"))
      continue;
    try {
      const content = await app.vault.adapter.read(filePath);
      const bookData = parseFrontmatter(content, filePath);
      if (bookData) {
        books.push(bookData);
      }
    } catch (error) {
      console.log(`MoonSync: Failed to read ${filePath}`, error);
    }
  }
  return books;
}
function parseFrontmatter(content, filePath) {
  if (!content.startsWith("---")) {
    return null;
  }
  const endIndex = content.indexOf("---", 3);
  if (endIndex === -1) {
    return null;
  }
  const frontmatter = content.substring(3, endIndex);
  const titleMatch = frontmatter.match(/^title:\s*"?([^"\n]+)"?/m);
  if (!titleMatch) {
    return null;
  }
  const title = titleMatch[1].trim();
  const authorMatch = frontmatter.match(/^author:\s*"?([^"\n]+)"?/m);
  const progressMatch = frontmatter.match(/^progress:\s*"?(\d+(?:\.\d+)?)/m);
  const highlightsMatch = frontmatter.match(/^highlights_count:\s*(\d+)/m);
  const coverMatch = frontmatter.match(/^cover:\s*"?([^"\n]+)"?/m);
  const moonReaderPathMatch = frontmatter.match(/^moon_reader_path:/m);
  const lastSyncedMatch = frontmatter.match(/^last_synced:\s*(\d{4}-\d{2}-\d{2})/m);
  const notesCount = (content.match(/\*\*Note:\*\*/g) || []).length;
  let lastReadTimestamp = null;
  if (lastSyncedMatch) {
    lastReadTimestamp = new Date(lastSyncedMatch[1]).getTime();
  }
  return {
    title,
    author: authorMatch ? authorMatch[1].trim() : null,
    progress: progressMatch ? parseFloat(progressMatch[1]) : null,
    highlightsCount: highlightsMatch ? parseInt(highlightsMatch[1], 10) : 0,
    notesCount,
    coverPath: coverMatch ? coverMatch[1].trim() : null,
    lastReadTimestamp,
    filePath,
    isMoonReader: !!moonReaderPathMatch
  };
}
function scannedBookToBookData(scanned) {
  const book = {
    id: 0,
    title: scanned.title,
    filename: "",
    author: scanned.author || "",
    description: "",
    category: "",
    thumbFile: "",
    coverFile: "",
    addTime: "",
    favorite: ""
  };
  const highlights = [];
  for (let i = 0; i < scanned.highlightsCount; i++) {
    highlights.push({
      id: i,
      book: scanned.title,
      filename: "",
      chapter: 0,
      position: 0,
      highlightLength: 0,
      highlightColor: 0,
      timestamp: 0,
      bookmark: "",
      note: i < scanned.notesCount ? "note" : "",
      // Mark first N as having notes
      originalText: "",
      underline: false,
      strikethrough: false
    });
  }
  return {
    book,
    highlights,
    statistics: null,
    progress: scanned.progress,
    currentChapter: null,
    lastReadTimestamp: scanned.lastReadTimestamp,
    coverPath: scanned.coverPath,
    fetchedDescription: null,
    rating: null,
    ratingsCount: null
  };
}
function mergeBookLists(moonReaderBooks, scannedBooks) {
  const result = [...moonReaderBooks];
  const moonReaderTitles = new Set(moonReaderBooks.map((b) => b.book.title.toLowerCase()));
  for (const scanned of scannedBooks) {
    if (!moonReaderTitles.has(scanned.title.toLowerCase())) {
      result.push(scannedBookToBookData(scanned));
    }
  }
  return result;
}

// src/sync.ts
async function syncFromMoonReader(app, settings, wasmPath) {
  const result = {
    success: false,
    booksProcessed: 0,
    booksCreated: 0,
    booksUpdated: 0,
    booksSkipped: 0,
    manualBooksAdded: 0,
    totalHighlights: 0,
    totalNotes: 0,
    isFirstSync: false,
    errors: []
  };
  const progressNotice = new import_obsidian6.Notice("MoonSync: Syncing...", 0);
  try {
    if (!settings.dropboxPath) {
      result.errors.push("Dropbox path not configured");
      progressNotice.hide();
      return result;
    }
    const booksWithHighlights = await parseAnnotationFiles(settings.dropboxPath);
    if (booksWithHighlights.length === 0) {
      result.errors.push("No annotation files found in .Moon+/Cache folder");
      progressNotice.hide();
      return result;
    }
    const outputPath = (0, import_obsidian6.normalizePath)(settings.outputFolder);
    const outputFolderExisted = await app.vault.adapter.exists(outputPath);
    result.isFirstSync = !outputFolderExisted;
    if (!outputFolderExisted) {
      await app.vault.createFolder(outputPath);
    }
    result.totalHighlights = booksWithHighlights.reduce((sum, b) => sum + b.highlights.length, 0);
    result.totalNotes = booksWithHighlights.reduce(
      (sum, b) => sum + b.highlights.filter((h) => h.note && h.note.trim()).length,
      0
    );
    const cache = await loadCache(app, outputPath);
    let cacheModified = false;
    for (const bookData of booksWithHighlights) {
      try {
        const processed = await processBook(app, outputPath, bookData, settings, result, cache);
        if (processed) {
          cacheModified = true;
        }
        result.booksProcessed++;
      } catch (error) {
        result.errors.push(
          `Error processing "${bookData.book.title}": ${error}`
        );
      }
    }
    const scannedBooks = await scanAllBookNotes(app, outputPath);
    const customBooks = scannedBooks.filter((book) => !book.isMoonReader);
    for (const customBook of customBooks) {
      try {
        const processed = await processCustomBook(app, outputPath, customBook, settings, result, cache);
        if (processed) {
          cacheModified = true;
        }
      } catch (error) {
        result.errors.push(
          `Error processing custom book "${customBook.title}": ${error}`
        );
      }
    }
    if (cacheModified) {
      await saveCache(app, outputPath, cache);
    }
    if (settings.showIndex) {
      const indexPath = (0, import_obsidian6.normalizePath)(`${outputPath}/${settings.indexNoteTitle}.md`);
      const indexExists = await app.vault.adapter.exists(indexPath);
      const scannedBooks2 = await scanAllBookNotes(app, outputPath);
      const indexFilename = `${settings.indexNoteTitle}.md`;
      const filteredScanned = scannedBooks2.filter((b) => !b.filePath.endsWith(indexFilename));
      const totalBookNotes = filteredScanned.length;
      const manualBookCount = totalBookNotes - booksWithHighlights.length;
      const hasManualBooks = manualBookCount > 0;
      if (hasManualBooks) {
        result.manualBooksAdded = manualBookCount;
      }
      if (result.booksCreated > 0 || result.booksUpdated > 0 || !indexExists || hasManualBooks) {
        const coversFolder = (0, import_obsidian6.normalizePath)(`${outputPath}/covers`);
        for (const bookData of booksWithHighlights) {
          if (!bookData.coverPath) {
            const coverFilename = `${generateFilename(bookData.book.title)}.jpg`;
            const coverPath = (0, import_obsidian6.normalizePath)(`${coversFolder}/${coverFilename}`);
            if (await app.vault.adapter.exists(coverPath)) {
              bookData.coverPath = `covers/${coverFilename}`;
            }
          }
        }
        await updateIndexNote(app, outputPath, booksWithHighlights, settings);
      }
    }
    if (settings.generateBaseFile) {
      const baseFilePath = (0, import_obsidian6.normalizePath)(`${outputPath}/${settings.baseFileName}.base`);
      const baseExists = await app.vault.adapter.exists(baseFilePath);
      if (result.booksCreated > 0 || result.booksUpdated > 0 || !baseExists) {
        await updateBaseFile(app, outputPath, settings);
      }
    }
    progressNotice.hide();
    result.success = true;
    return result;
  } catch (error) {
    progressNotice.hide();
    result.errors.push(`Sync failed: ${error}`);
    return result;
  }
}
async function getExistingBookData(app, filePath) {
  try {
    if (!await app.vault.adapter.exists(filePath)) {
      return null;
    }
    const content = await app.vault.adapter.read(filePath);
    const countMatch = content.match(/^highlights_count:\s*(\d+)/m);
    const progressMatch = content.match(/^progress:\s*"?(\d+(?:\.\d+)?)/m);
    const manualNoteMatch = content.match(/^manual_note:\s*true/m);
    if (countMatch) {
      return {
        highlightsCount: parseInt(countMatch[1], 10),
        progress: progressMatch ? parseFloat(progressMatch[1]) : null,
        isManualNote: !!manualNoteMatch,
        fullContent: content
      };
    }
  } catch (e) {
  }
  return null;
}
function mergeManualNoteWithMoonReader(existingContent, bookData, settings) {
  const lines = [];
  const frontmatterMatch = existingContent.match(/^---\n([\s\S]*?)\n---/);
  const contentAfterFrontmatter = frontmatterMatch ? existingContent.slice(frontmatterMatch[0].length).trim() : existingContent.trim();
  lines.push("---");
  if (frontmatterMatch) {
    const frontmatter = frontmatterMatch[1];
    const frontmatterLines = frontmatter.split("\n");
    for (const line of frontmatterLines) {
      if (line.startsWith("progress:") || line.startsWith("current_chapter:") || line.startsWith("highlights_count:") || line.startsWith("notes_count:") || line.startsWith("last_synced:") || line.startsWith("manual_note:") || line.startsWith("published_date:") || line.startsWith("publisher:") || line.startsWith("page_count:") || line.startsWith("genres:") || line.startsWith("series:") || line.startsWith("language:") || line.startsWith("rating:") || line.startsWith("ratings_count:") || line.trim().startsWith("-")) {
        continue;
      }
      lines.push(line);
    }
  }
  lines.push(`last_synced: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  lines.push(`highlights_count: ${bookData.highlights.length}`);
  const notesCount = bookData.highlights.filter((h) => h.note && h.note.trim()).length;
  lines.push(`notes_count: ${notesCount}`);
  if (settings.showProgress && bookData.progress !== null) {
    lines.push(`progress: "${bookData.progress.toFixed(1)}%"`);
    if (bookData.currentChapter) {
      lines.push(`current_chapter: ${bookData.currentChapter}`);
    }
  }
  if (bookData.publishedDate) {
    lines.push(`published_date: "${bookData.publishedDate.replace(/"/g, '\\"')}"`);
  }
  if (bookData.publisher) {
    lines.push(`publisher: "${bookData.publisher.replace(/"/g, '\\"')}"`);
  }
  if (bookData.pageCount !== null) {
    lines.push(`page_count: ${bookData.pageCount}`);
  }
  if (bookData.genres && bookData.genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of bookData.genres) {
      lines.push(`  - "${genre.replace(/"/g, '\\"')}"`);
    }
  }
  if (bookData.series) {
    lines.push(`series: "${bookData.series.replace(/"/g, '\\"')}"`);
  }
  if (bookData.language) {
    lines.push(`language: "${bookData.language}"`);
  }
  lines.push("---");
  lines.push("");
  lines.push(contentAfterFrontmatter);
  lines.push("");
  lines.push("## Moon+ Reader Highlights");
  lines.push("");
  if (settings.showReadingProgress && (bookData.progress !== null || bookData.currentChapter !== null)) {
    lines.push("**Reading Progress:**");
    if (bookData.progress !== null) {
      lines.push(`- Progress: ${bookData.progress.toFixed(1)}%`);
    }
    if (bookData.currentChapter !== null) {
      lines.push(`- Chapter: ${bookData.currentChapter}`);
    }
    lines.push("");
  }
  for (const highlight of bookData.highlights) {
    lines.push(formatHighlight(highlight, settings.showHighlightColors, settings.showNotes));
    lines.push("");
  }
  return lines.join("\n");
}
function calculateSimilarity(str1, str2) {
  const s1 = str1.toLowerCase();
  const s2 = str2.toLowerCase();
  if (s1 === s2)
    return 1;
  const len1 = s1.length;
  const len2 = s2.length;
  if (len1 === 0)
    return len2 === 0 ? 1 : 0;
  if (len2 === 0)
    return 0;
  const matrix = [];
  for (let i = 0; i <= len1; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= len2; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        // deletion
        matrix[i][j - 1] + 1,
        // insertion
        matrix[i - 1][j - 1] + cost
        // substitution
      );
    }
  }
  const distance = matrix[len1][len2];
  const maxLen = Math.max(len1, len2);
  return 1 - distance / maxLen;
}
function normalizeBookTitle2(title) {
  return title.replace(/\.(epub|mobi|pdf|azw3?|fb2|txt)$/i, "").trim();
}
async function findExistingFile(app, outputPath, preferredFilename, bookTitle) {
  const preferredPath = (0, import_obsidian6.normalizePath)(`${outputPath}/${preferredFilename}.md`);
  if (await app.vault.adapter.exists(preferredPath)) {
    return preferredPath;
  }
  const normalizedBookTitle = normalizeBookTitle2(bookTitle);
  try {
    const listing = await app.vault.adapter.list((0, import_obsidian6.normalizePath)(outputPath));
    const SIMILARITY_THRESHOLD = 0.8;
    let bestMatch = null;
    for (const filePath of listing.files) {
      if (!filePath.endsWith(".md"))
        continue;
      try {
        const content = await app.vault.adapter.read(filePath);
        const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        if (!frontmatterMatch)
          continue;
        const frontmatter = frontmatterMatch[1];
        const titleMatch = frontmatter.match(/^title:\s*"?(.+?)"?\s*$/m);
        if (titleMatch) {
          let existingTitle = titleMatch[1].trim().replace(/\\"/g, '"');
          const normalizedExistingTitle = normalizeBookTitle2(existingTitle);
          const similarity = calculateSimilarity(normalizedBookTitle, normalizedExistingTitle);
          if (similarity >= SIMILARITY_THRESHOLD) {
            if (!bestMatch || similarity > bestMatch.similarity) {
              bestMatch = { path: filePath, similarity };
            }
          }
        }
      } catch (error) {
        continue;
      }
    }
    if (bestMatch) {
      console.log(`Best match: "${bestMatch.path}" (${(bestMatch.similarity * 100).toFixed(1)}%)`);
      if (bestMatch.path !== preferredPath) {
        try {
          await app.vault.adapter.rename(bestMatch.path, preferredPath);
          return preferredPath;
        } catch (error) {
          return bestMatch.path;
        }
      }
      return bestMatch.path;
    }
  } catch (error) {
  }
  return preferredPath;
}
async function processBook(app, outputPath, bookData, settings, result, cache) {
  const originalTitle = bookData.book.title;
  const originalAuthor = bookData.book.author;
  const filename = generateFilename(bookData.book.title);
  const filePath = await findExistingFile(app, outputPath, filename, bookData.book.title);
  let cacheModified = false;
  const cachedInfo = getCachedInfo(cache, originalTitle, originalAuthor);
  const hasAttemptedFetch = cachedInfo && (cachedInfo.publishedDate !== void 0 && cachedInfo.publisher !== void 0 && cachedInfo.pageCount !== void 0 && cachedInfo.genres !== void 0 && cachedInfo.series !== void 0 && cachedInfo.language !== void 0);
  const existingData = await getExistingBookData(app, filePath);
  const fileExists = existingData !== null;
  if (fileExists) {
    const highlightsUnchanged = existingData.highlightsCount === bookData.highlights.length;
    const progressUnchanged = existingData.progress === bookData.progress;
    console.log(`[${bookData.book.title}] Existing: ${existingData.highlightsCount} highlights, ${existingData.progress}% | New: ${bookData.highlights.length} highlights, ${bookData.progress}%`);
    console.log(`[${bookData.book.title}] Unchanged: highlights=${highlightsUnchanged}, progress=${progressUnchanged}, hasAttemptedFetch=${hasAttemptedFetch}`);
    if (highlightsUnchanged && progressUnchanged && hasAttemptedFetch) {
      result.booksSkipped++;
      return false;
    }
  }
  const shouldFetchMetadata = true;
  if (shouldFetchMetadata) {
    const coverFilename = `${filename}.jpg`;
    const coversFolder = (0, import_obsidian6.normalizePath)(`${outputPath}/covers`);
    const coverPath = (0, import_obsidian6.normalizePath)(`${coversFolder}/${coverFilename}`);
    const coverExists = await app.vault.adapter.exists(coverPath);
    if (cachedInfo) {
      if (cachedInfo.description) {
        bookData.fetchedDescription = cachedInfo.description;
      }
      if (!bookData.book.author && cachedInfo.author) {
        bookData.book.author = cachedInfo.author;
      }
      if (cachedInfo.publishedDate) {
        bookData.publishedDate = cachedInfo.publishedDate;
      }
      if (cachedInfo.publisher) {
        bookData.publisher = cachedInfo.publisher;
      }
      if (cachedInfo.pageCount !== null) {
        bookData.pageCount = cachedInfo.pageCount;
      }
      if (cachedInfo.genres) {
        bookData.genres = cachedInfo.genres;
      }
      if (cachedInfo.series) {
        bookData.series = cachedInfo.series;
      }
      if (cachedInfo.language) {
        bookData.language = cachedInfo.language;
      }
    }
    const needsApiFetch = !coverExists || !hasAttemptedFetch;
    if (needsApiFetch) {
      try {
        const bookInfo = await fetchBookInfo(
          bookData.book.title,
          bookData.book.author
        );
        if (settings.fetchCovers && bookInfo.coverUrl && !coverExists) {
          if (!await app.vault.adapter.exists(coversFolder)) {
            await app.vault.createFolder(coversFolder);
          }
          const imageData = await downloadCover(bookInfo.coverUrl);
          if (imageData) {
            await app.vault.adapter.writeBinary(coverPath, imageData);
            bookData.coverPath = `covers/${coverFilename}`;
          }
        }
        if (bookInfo.description) {
          bookData.fetchedDescription = bookInfo.description;
        }
        if (!bookData.book.author && bookInfo.author) {
          bookData.book.author = bookInfo.author;
        }
        if (bookInfo.title) {
          bookData.book.title = bookInfo.title;
        }
        if (bookInfo.publishedDate) {
          bookData.publishedDate = bookInfo.publishedDate;
        }
        if (bookInfo.publisher) {
          bookData.publisher = bookInfo.publisher;
        }
        if (bookInfo.pageCount !== null) {
          bookData.pageCount = bookInfo.pageCount;
        }
        if (bookInfo.genres) {
          bookData.genres = bookInfo.genres;
        }
        if (bookInfo.series) {
          bookData.series = bookInfo.series;
        }
        if (bookInfo.language) {
          bookData.language = bookInfo.language;
        }
        setCachedInfo(cache, originalTitle, originalAuthor, {
          description: bookInfo.description,
          author: bookInfo.author,
          publishedDate: bookInfo.publishedDate,
          publisher: bookInfo.publisher,
          pageCount: bookInfo.pageCount,
          genres: bookInfo.genres,
          series: bookInfo.series,
          language: bookInfo.language
        });
        cacheModified = true;
      } catch (error) {
        console.log(`MoonSync: Failed to fetch book info for "${bookData.book.title}"`, error);
      }
    }
    if (settings.fetchCovers && coverExists) {
      bookData.coverPath = `covers/${coverFilename}`;
    }
  }
  let markdown;
  if (fileExists && existingData.isManualNote) {
    markdown = mergeManualNoteWithMoonReader(existingData.fullContent, bookData, settings);
  } else {
    markdown = generateBookNote(bookData, settings);
  }
  if (fileExists) {
    await app.vault.adapter.write(filePath, markdown);
    result.booksUpdated++;
  } else {
    await app.vault.create(filePath, markdown);
    result.booksCreated++;
  }
  return cacheModified;
}
async function processCustomBook(app, outputPath, scannedBook, settings, result, cache) {
  let cacheModified = false;
  const cachedInfo = getCachedInfo(cache, scannedBook.title, scannedBook.author || "");
  if (cachedInfo && cachedInfo.publishedDate !== void 0 && cachedInfo.publisher !== void 0 && cachedInfo.pageCount !== void 0 && cachedInfo.genres !== void 0 && cachedInfo.series !== void 0 && cachedInfo.language !== void 0) {
    return false;
  }
  const author = scannedBook.author || "Unknown";
  const bookInfo = await fetchBookInfo(scannedBook.title, author);
  if (bookInfo.coverUrl || bookInfo.description || bookInfo.publishedDate || bookInfo.publisher || bookInfo.pageCount !== null || bookInfo.genres || bookInfo.series || bookInfo.language) {
    const content = await app.vault.adapter.read(scannedBook.filePath);
    const updatedContent = updateCustomBookFrontmatter(content, bookInfo, settings);
    await app.vault.adapter.write(scannedBook.filePath, updatedContent);
    setCachedInfo(cache, scannedBook.title, scannedBook.author, {
      description: bookInfo.description,
      author: bookInfo.author,
      publishedDate: bookInfo.publishedDate,
      publisher: bookInfo.publisher,
      pageCount: bookInfo.pageCount,
      genres: bookInfo.genres,
      series: bookInfo.series,
      language: bookInfo.language
    });
    cacheModified = true;
    result.booksUpdated++;
    if (bookInfo.coverUrl) {
      const coverFilename = `${generateFilename(scannedBook.title)}.jpg`;
      const coversFolder = (0, import_obsidian6.normalizePath)(`${outputPath}/covers`);
      const coverPath = (0, import_obsidian6.normalizePath)(`${coversFolder}/${coverFilename}`);
      if (!await app.vault.adapter.exists(coverPath)) {
        if (!await app.vault.adapter.exists(coversFolder)) {
          await app.vault.createFolder(coversFolder);
        }
        const imageData = await downloadCover(bookInfo.coverUrl);
        if (imageData) {
          await app.vault.adapter.writeBinary(coverPath, imageData);
        }
      }
    }
  }
  return cacheModified;
}
function updateCustomBookFrontmatter(content, bookInfo, settings) {
  var _a, _b;
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    return content;
  }
  const frontmatter = frontmatterMatch[1];
  const contentAfterFrontmatter = content.slice(frontmatterMatch[0].length);
  const lines = [];
  lines.push("---");
  const frontmatterLines = frontmatter.split("\n");
  let skipNextLine = false;
  for (const line of frontmatterLines) {
    if (skipNextLine && line.trim().startsWith("-")) {
      continue;
    }
    skipNextLine = false;
    if (line.startsWith("published_date:") || line.startsWith("publisher:") || line.startsWith("page_count:") || line.startsWith("genres:") || line.startsWith("series:") || line.startsWith("language:") || line.startsWith("rating:") || line.startsWith("ratings_count:") || line.startsWith("cover:")) {
      if (line.startsWith("genres:")) {
        skipNextLine = true;
      }
      continue;
    }
    lines.push(line);
  }
  if (bookInfo.publishedDate) {
    lines.push(`published_date: "${escapeYaml2(bookInfo.publishedDate)}"`);
  }
  if (bookInfo.publisher) {
    lines.push(`publisher: "${escapeYaml2(bookInfo.publisher)}"`);
  }
  if (bookInfo.pageCount !== null) {
    lines.push(`page_count: ${bookInfo.pageCount}`);
  }
  if (bookInfo.genres && bookInfo.genres.length > 0) {
    lines.push(`genres:`);
    for (const genre of bookInfo.genres) {
      lines.push(`  - "${escapeYaml2(genre)}"`);
    }
  }
  if (bookInfo.series) {
    lines.push(`series: "${escapeYaml2(bookInfo.series)}"`);
  }
  if (bookInfo.language) {
    lines.push(`language: "${bookInfo.language}"`);
  }
  const coverFilename = generateFilename(((_b = (_a = frontmatterLines.find((l) => l.startsWith("title:"))) == null ? void 0 : _a.split(":")[1]) == null ? void 0 : _b.trim().replace(/"/g, "")) || "");
  if (coverFilename) {
    lines.push(`cover: "covers/${coverFilename}.jpg"`);
  }
  lines.push("---");
  return lines.join("\n") + contentAfterFrontmatter;
}
function escapeYaml2(str) {
  return str.replace(/"/g, '\\"').replace(/\n/g, " ");
}
async function updateIndexNote(app, outputPath, moonReaderBooks, settings) {
  const indexPath = (0, import_obsidian6.normalizePath)(`${outputPath}/${settings.indexNoteTitle}.md`);
  const scannedBooks = await scanAllBookNotes(app, outputPath);
  const indexFilename = `${settings.indexNoteTitle}.md`;
  const filteredScanned = scannedBooks.filter(
    (b) => !b.filePath.endsWith(indexFilename)
  );
  const allBooks = mergeBookLists(moonReaderBooks, filteredScanned);
  const markdown = generateIndexNote(allBooks, settings);
  if (await app.vault.adapter.exists(indexPath)) {
    await app.vault.adapter.write(indexPath, markdown);
  } else {
    await app.vault.create(indexPath, markdown);
  }
}
async function refreshIndexNote(app, settings) {
  if (!settings.showIndex) {
    new import_obsidian6.Notice("MoonSync: Index generation is disabled in settings");
    return;
  }
  const outputPath = (0, import_obsidian6.normalizePath)(settings.outputFolder);
  if (!await app.vault.adapter.exists(outputPath)) {
    new import_obsidian6.Notice("MoonSync: Output folder does not exist");
    return;
  }
  try {
    let moonReaderBooks = [];
    if (settings.dropboxPath) {
      try {
        moonReaderBooks = await parseAnnotationFiles(settings.dropboxPath);
      } catch (e) {
      }
    }
    const coversFolder = (0, import_obsidian6.normalizePath)(`${outputPath}/covers`);
    for (const bookData of moonReaderBooks) {
      if (!bookData.coverPath) {
        const coverFilename = `${generateFilename(bookData.book.title)}.jpg`;
        const coverPath = (0, import_obsidian6.normalizePath)(`${coversFolder}/${coverFilename}`);
        if (await app.vault.adapter.exists(coverPath)) {
          bookData.coverPath = `covers/${coverFilename}`;
        }
      }
    }
    await updateIndexNote(app, outputPath, moonReaderBooks, settings);
    new import_obsidian6.Notice("MoonSync: Index refreshed");
  } catch (error) {
    console.error("MoonSync: Failed to refresh index", error);
    new import_obsidian6.Notice("MoonSync: Failed to refresh index");
  }
}
async function updateBaseFile(app, outputPath, settings) {
  const baseFilePath = (0, import_obsidian6.normalizePath)(`${outputPath}/${settings.baseFileName}.base`);
  const content = generateBaseFile(settings);
  if (await app.vault.adapter.exists(baseFilePath)) {
    await app.vault.adapter.write(baseFilePath, content);
  } else {
    await app.vault.create(baseFilePath, content);
  }
}
async function refreshBaseFile(app, settings) {
  if (!settings.generateBaseFile) {
    new import_obsidian6.Notice("MoonSync: Base file generation is disabled in settings");
    return;
  }
  const outputPath = (0, import_obsidian6.normalizePath)(settings.outputFolder);
  if (!await app.vault.adapter.exists(outputPath)) {
    new import_obsidian6.Notice("MoonSync: Output folder does not exist");
    return;
  }
  try {
    await updateBaseFile(app, outputPath, settings);
    new import_obsidian6.Notice("MoonSync: Base file refreshed");
  } catch (error) {
    console.error("MoonSync: Failed to refresh base file", error);
    new import_obsidian6.Notice("MoonSync: Failed to refresh base file");
  }
}
function showSyncResults(app, result) {
  if (result.success) {
    if (result.booksProcessed === 0) {
      new import_obsidian6.Notice("MoonSync: No books with highlights to sync");
    } else if (result.isFirstSync) {
      new SyncSummaryModal(app, result).open();
    } else {
      const totalProcessed = result.booksCreated + result.booksUpdated;
      const totalBooks = totalProcessed + result.booksSkipped + result.manualBooksAdded;
      if (totalProcessed === 0) {
        new import_obsidian6.Notice("MoonSync: All books up to date");
      } else {
        new import_obsidian6.Notice(`MoonSync: Updated ${totalProcessed} of ${totalBooks} books`);
      }
    }
  } else {
    new import_obsidian6.Notice(`MoonSync: Sync failed - ${result.errors[0]}`);
  }
  for (const error of result.errors) {
    console.error("MoonSync:", error);
  }
}

// main.ts
var import_path2 = require("path");
var MoonSyncPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.ribbonIconEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new MoonSyncSettingTab(this.app, this));
    this.updateRibbonIcon();
    this.addCommand({
      id: "sync-now",
      name: "Sync Now",
      callback: () => this.runSync()
    });
    this.addCommand({
      id: "create-book-note",
      name: "Create Book Note",
      callback: () => this.openCreateBookModal()
    });
    this.addCommand({
      id: "force-refresh-metadata",
      name: "Force Refresh All Metadata",
      callback: () => this.forceRefreshMetadata()
    });
    if (this.settings.syncOnStartup) {
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => this.runSync(), 2e3);
      });
    }
  }
  updateRibbonIcon() {
    if (this.ribbonIconEl) {
      this.ribbonIconEl.remove();
      this.ribbonIconEl = null;
    }
    if (this.settings.showRibbonIcon) {
      this.ribbonIconEl = this.addRibbonIcon(
        "book-open",
        "MoonSync: Sync Now",
        () => this.runSync()
      );
    }
  }
  async runSync() {
    if (!this.settings.dropboxPath) {
      new import_obsidian7.Notice("MoonSync: Please configure the Dropbox path in settings");
      return;
    }
    try {
      const wasmPath = this.getWasmPath();
      const result = await syncFromMoonReader(
        this.app,
        this.settings,
        wasmPath
      );
      showSyncResults(this.app, result);
    } catch (error) {
      console.error("MoonSync sync error:", error);
      new import_obsidian7.Notice(`MoonSync: Sync failed - ${error}`);
    }
  }
  /**
   * Get the path to the sql-wasm.wasm file bundled with the plugin
   */
  getWasmPath() {
    const pluginDir = this.app.vault.adapter.basePath;
    const pluginPath = this.manifest.dir;
    if (pluginPath) {
      return (0, import_path2.join)(pluginDir, pluginPath, "sql-wasm.wasm");
    }
    throw new Error("Could not determine plugin directory");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Open the modal to create a new book note
   */
  openCreateBookModal() {
    new CreateBookModal(
      this.app,
      this.settings,
      async (title, author) => {
        await this.createBookNote(title, author);
      }
    ).open();
  }
  /**
   * Create a new book note with the given title and author
   */
  async createBookNote(title, author) {
    const progressNotice = new import_obsidian7.Notice("MoonSync: Creating book note...", 0);
    try {
      const outputPath = (0, import_obsidian7.normalizePath)(this.settings.outputFolder);
      const filename = generateFilename(title);
      const filePath = (0, import_obsidian7.normalizePath)(`${outputPath}/${filename}.md`);
      if (await this.app.vault.adapter.exists(filePath)) {
        progressNotice.hide();
        new import_obsidian7.Notice(`MoonSync: A note for "${title}" already exists`);
        return;
      }
      if (!await this.app.vault.adapter.exists(outputPath)) {
        await this.app.vault.createFolder(outputPath);
      }
      let coverPath = null;
      let description = null;
      let rating = null;
      let ratingsCount = null;
      let fetchedAuthor = null;
      let publishedDate = null;
      let publisher = null;
      let pageCount = null;
      let genres = null;
      let series = null;
      let language = null;
      if (this.settings.fetchCovers || this.settings.showDescription || this.settings.showRatings) {
        try {
          const bookInfo = await fetchBookInfo(title, author);
          if (this.settings.fetchCovers && bookInfo.coverUrl) {
            const coversFolder = (0, import_obsidian7.normalizePath)(`${outputPath}/covers`);
            if (!await this.app.vault.adapter.exists(coversFolder)) {
              await this.app.vault.createFolder(coversFolder);
            }
            const coverFilename = `${filename}.jpg`;
            const coverFilePath = (0, import_obsidian7.normalizePath)(`${coversFolder}/${coverFilename}`);
            const imageData = await downloadCover(bookInfo.coverUrl);
            if (imageData) {
              await this.app.vault.adapter.writeBinary(coverFilePath, imageData);
              coverPath = `covers/${coverFilename}`;
            }
          }
          description = bookInfo.description;
          rating = bookInfo.rating;
          ratingsCount = bookInfo.ratingsCount;
          fetchedAuthor = bookInfo.author;
          publishedDate = bookInfo.publishedDate;
          publisher = bookInfo.publisher;
          pageCount = bookInfo.pageCount;
          genres = bookInfo.genres;
          series = bookInfo.series;
          language = bookInfo.language;
        } catch (error) {
          console.log(`MoonSync: Failed to fetch book info for "${title}"`, error);
        }
      }
      const finalAuthor = author || fetchedAuthor || "";
      const content = generateBookTemplate(
        title,
        finalAuthor,
        coverPath,
        this.settings.showDescription ? description : null,
        this.settings.showRatings ? rating : null,
        this.settings.showRatings ? ratingsCount : null,
        publishedDate,
        publisher,
        pageCount,
        genres,
        series,
        language
      );
      await this.app.vault.create(filePath, content);
      progressNotice.hide();
      new import_obsidian7.Notice(`MoonSync: Created note for "${title}"`);
      if (this.settings.showIndex) {
        await refreshIndexNote(this.app, this.settings);
      }
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        await this.app.workspace.openLinkText(filePath, "", true);
      }
    } catch (error) {
      progressNotice.hide();
      console.error("MoonSync: Failed to create book note", error);
      new import_obsidian7.Notice(`MoonSync: Failed to create book note - ${error}`);
    }
  }
  async refreshIndex() {
    await refreshIndexNote(this.app, this.settings);
  }
  async refreshBase() {
    await refreshBaseFile(this.app, this.settings);
  }
  async forceRefreshMetadata() {
    const notice = new import_obsidian7.Notice("Force refreshing metadata for all books...", 0);
    try {
      const cacheFile = (0, import_obsidian7.normalizePath)(`${this.settings.outputFolder}/.moonsync-cache.json`);
      if (await this.app.vault.adapter.exists(cacheFile)) {
        await this.app.vault.adapter.remove(cacheFile);
      }
      await this.runSync();
      notice.hide();
    } catch (error) {
      notice.hide();
      new import_obsidian7.Notice(`Failed to refresh metadata: ${error}`);
    }
  }
};
